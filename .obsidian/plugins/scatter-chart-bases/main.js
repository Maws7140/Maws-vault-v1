/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ScatterPlotPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/scatter-view.ts
var import_obsidian2 = require("obsidian");

// src/types.ts
var DEFAULT_PALETTE = {
  fallback: "var(--text-muted)",
  colors: [
    "var(--color-blue)",
    "var(--color-green)",
    "var(--color-yellow)",
    "var(--color-orange)",
    "var(--color-red)",
    "var(--color-purple)",
    "var(--color-pink)",
    "var(--color-cyan)"
  ]
};
var DEFAULT_VIEWPORT = {
  width: 800,
  height: 600,
  margin: {
    top: 20,
    right: 20,
    bottom: 40,
    left: 50
  }
};

// src/data.ts
var isValueEmpty = (value) => {
  if (value === null || value === void 0)
    return true;
  if (typeof value === "object" && value !== null && "isEmpty" in value) {
    const v = value;
    return v.isEmpty();
  }
  return !value;
};
var extractNumericValue = (entry, propertyId) => {
  try {
    const value = entry.getValue(propertyId);
    if (value === null || value === void 0 || isValueEmpty(value)) {
      return { success: false, reason: `Property "${propertyId}" is empty` };
    }
    const stringValue = value.toString();
    const numericValue = Number(stringValue);
    if (Number.isNaN(numericValue)) {
      return {
        success: false,
        reason: `Property "${propertyId}" value "${stringValue}" is not numeric`
      };
    }
    if (!Number.isFinite(numericValue)) {
      return {
        success: false,
        reason: `Property "${propertyId}" value is not finite`
      };
    }
    return { success: true, value: numericValue };
  } catch (e) {
    return {
      success: false,
      reason: `Failed to read property "${propertyId}": ${String(e)}`
    };
  }
};
var extractCategoryValue = (entry, propertyId) => {
  if (propertyId === null) {
    return { success: false };
  }
  try {
    const value = entry.getValue(propertyId);
    if (value === null || value === void 0 || isValueEmpty(value)) {
      return { success: false };
    }
    return { success: true, value: value.toString() };
  } catch (e) {
    return { success: false };
  }
};
var entryToPoint = (entry, config) => {
  const { xAxis, yAxis, colorBy } = config;
  if (xAxis === null) {
    return { file: entry.file, reason: "X axis property not configured" };
  }
  if (yAxis === null) {
    return { file: entry.file, reason: "Y axis property not configured" };
  }
  const xResult = extractNumericValue(entry, xAxis);
  if (!xResult.success) {
    return { file: entry.file, reason: xResult.reason };
  }
  const yResult = extractNumericValue(entry, yAxis);
  if (!yResult.success) {
    return { file: entry.file, reason: yResult.reason };
  }
  const categoryResult = extractCategoryValue(entry, colorBy);
  const category = categoryResult.success ? categoryResult.value : null;
  return {
    x: xResult.value,
    y: yResult.value,
    category,
    label: entry.file.basename,
    file: entry.file,
    entry
  };
};
var isScatterPoint = (result) => {
  return "x" in result && "y" in result;
};
var extractCategories = (points) => {
  const seen = /* @__PURE__ */ new Set();
  const categories = [];
  for (const point of points) {
    if (point.category !== null && !seen.has(point.category)) {
      seen.add(point.category);
      categories.push(point.category);
    }
  }
  return categories;
};
var extractDataFromEntries = (entries, config) => {
  const points = [];
  const skipped = [];
  for (const entry of entries) {
    const result = entryToPoint(entry, config);
    if (isScatterPoint(result)) {
      points.push(result);
    } else {
      skipped.push(result);
    }
  }
  const categories = extractCategories(points);
  return { points, skipped, categories };
};
var flattenGroupedData = (groupedData) => {
  return groupedData.flatMap((group) => [...group.entries]);
};
var calculateAxisBounds = (values, paddingPercent = 0.05) => {
  if (values.length === 0) {
    return null;
  }
  const min = Math.min(...values);
  const max = Math.max(...values);
  const range = max - min;
  const padding = range === 0 ? Math.abs(min) * paddingPercent || 1 : range * paddingPercent;
  return {
    min: min - padding,
    max: max + padding
  };
};
var calculatePlotBounds = (points, paddingPercent = 0.05) => {
  if (points.length === 0) {
    return null;
  }
  const xValues = points.map((p) => p.x);
  const yValues = points.map((p) => p.y);
  const xBounds = calculateAxisBounds(xValues, paddingPercent);
  const yBounds = calculateAxisBounds(yValues, paddingPercent);
  if (xBounds === null || yBounds === null) {
    return null;
  }
  return { x: xBounds, y: yBounds };
};
var createLinearScale = (domainMin, domainMax, rangeMin, rangeMax) => {
  const domainSpan = domainMax - domainMin;
  const rangeSpan = rangeMax - rangeMin;
  if (domainSpan === 0) {
    return () => (rangeMin + rangeMax) / 2;
  }
  return (value) => {
    const normalized = (value - domainMin) / domainSpan;
    return rangeMin + normalized * rangeSpan;
  };
};

// src/render.ts
var SVG_NS = "http://www.w3.org/2000/svg";
var createSvgElement = (tag, attributes = {}) => {
  const element = document.createElementNS(SVG_NS, tag);
  for (const [key, value] of Object.entries(attributes)) {
    element.setAttribute(key, String(value));
  }
  return element;
};
var calculateInnerDimensions = (viewport) => ({
  width: viewport.width - viewport.margin.left - viewport.margin.right,
  height: viewport.height - viewport.margin.top - viewport.margin.bottom
});
var createCategoryColorMap = (categories, palette = DEFAULT_PALETTE) => {
  const colorMap = /* @__PURE__ */ new Map();
  categories.forEach((category, index) => {
    const colorIndex = index % palette.colors.length;
    colorMap.set(category, palette.colors[colorIndex]);
  });
  return colorMap;
};
var getPointColor = (point, colorMap, fallback = DEFAULT_PALETTE.fallback) => {
  var _a;
  if (point.category === null) {
    return fallback;
  }
  return (_a = colorMap.get(point.category)) != null ? _a : fallback;
};
var transformPointsToScreen = (points, bounds, inner, colorMap, palette = DEFAULT_PALETTE) => {
  const scaleX = createLinearScale(bounds.x.min, bounds.x.max, 0, inner.width);
  const scaleY = createLinearScale(bounds.y.min, bounds.y.max, inner.height, 0);
  return points.map((point) => ({
    ...point,
    screenX: scaleX(point.x),
    screenY: scaleY(point.y),
    color: getPointColor(point, colorMap, palette.fallback)
  }));
};
var DEFAULT_TICK_CONFIG = {
  count: 5,
  format: (v) => v.toLocaleString(void 0, { maximumFractionDigits: 2 })
};
var generateTicks = (bounds, count = DEFAULT_TICK_CONFIG.count) => {
  const range = bounds.max - bounds.min;
  const step = range / (count - 1);
  return Array.from({ length: count }, (_, i) => bounds.min + i * step);
};
var createXAxis = (bounds, inner, label, tickConfig = DEFAULT_TICK_CONFIG) => {
  const group = createSvgElement("g", { class: "scatter-axis scatter-axis-x" });
  const scale = createLinearScale(bounds.min, bounds.max, 0, inner.width);
  const ticks = generateTicks(bounds, tickConfig.count);
  const axisLine = createSvgElement("line", {
    x1: 0,
    y1: inner.height,
    x2: inner.width,
    y2: inner.height,
    class: "scatter-axis-line",
    stroke: "var(--text-muted)",
    "stroke-width": 1
  });
  group.appendChild(axisLine);
  for (const tick of ticks) {
    const x = scale(tick);
    const tickLine = createSvgElement("line", {
      x1: x,
      y1: inner.height,
      x2: x,
      y2: inner.height + 6,
      class: "scatter-tick",
      stroke: "var(--text-muted)",
      "stroke-width": 1
    });
    group.appendChild(tickLine);
    const tickLabel = createSvgElement("text", {
      x,
      y: inner.height + 20,
      class: "scatter-tick-label",
      "text-anchor": "middle",
      fill: "var(--text-muted)",
      "font-size": "11px"
    });
    tickLabel.textContent = tickConfig.format(tick);
    group.appendChild(tickLabel);
  }
  const axisLabel = createSvgElement("text", {
    x: inner.width / 2,
    y: inner.height + 35,
    class: "scatter-axis-label",
    "text-anchor": "middle",
    fill: "var(--text-normal)",
    "font-size": "12px"
  });
  axisLabel.textContent = label;
  group.appendChild(axisLabel);
  return group;
};
var createYAxis = (bounds, inner, label, tickConfig = DEFAULT_TICK_CONFIG) => {
  const group = createSvgElement("g", { class: "scatter-axis scatter-axis-y" });
  const scale = createLinearScale(bounds.min, bounds.max, inner.height, 0);
  const ticks = generateTicks(bounds, tickConfig.count);
  const axisLine = createSvgElement("line", {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: inner.height,
    class: "scatter-axis-line",
    stroke: "var(--text-muted)",
    "stroke-width": 1
  });
  group.appendChild(axisLine);
  for (const tick of ticks) {
    const y = scale(tick);
    const tickLine = createSvgElement("line", {
      x1: -6,
      y1: y,
      x2: 0,
      y2: y,
      class: "scatter-tick",
      stroke: "var(--text-muted)",
      "stroke-width": 1
    });
    group.appendChild(tickLine);
    const tickLabel = createSvgElement("text", {
      x: -10,
      y: y + 4,
      class: "scatter-tick-label",
      "text-anchor": "end",
      fill: "var(--text-muted)",
      "font-size": "11px"
    });
    tickLabel.textContent = tickConfig.format(tick);
    group.appendChild(tickLabel);
  }
  const axisLabel = createSvgElement("text", {
    x: -inner.height / 2,
    y: -35,
    class: "scatter-axis-label",
    "text-anchor": "middle",
    fill: "var(--text-normal)",
    "font-size": "12px",
    transform: "rotate(-90)"
  });
  axisLabel.textContent = label;
  group.appendChild(axisLabel);
  return group;
};
var DEFAULT_POINT_CONFIG = {
  radius: 8,
  opacity: 0.7,
  hoverRadius: 12
};
var createPointElement = (point, config = DEFAULT_POINT_CONFIG) => {
  const circle = createSvgElement("circle", {
    cx: point.screenX,
    cy: point.screenY,
    r: config.radius,
    fill: point.color,
    opacity: config.opacity,
    class: "scatter-point",
    "data-file-path": point.file.path
  });
  return circle;
};
var createPointsLayer = (points, config = DEFAULT_POINT_CONFIG) => {
  const group = createSvgElement("g", { class: "scatter-points" });
  for (const point of points) {
    const circle = createPointElement(point, config);
    group.appendChild(circle);
  }
  return group;
};
var createGridLines = (xBounds, yBounds, inner, tickCount = 5) => {
  const group = createSvgElement("g", { class: "scatter-grid" });
  const xScale = createLinearScale(xBounds.min, xBounds.max, 0, inner.width);
  const yScale = createLinearScale(yBounds.min, yBounds.max, inner.height, 0);
  const xTicks = generateTicks(xBounds, tickCount);
  const yTicks = generateTicks(yBounds, tickCount);
  for (const tick of xTicks) {
    const x = xScale(tick);
    const line = createSvgElement("line", {
      x1: x,
      y1: 0,
      x2: x,
      y2: inner.height,
      class: "scatter-grid-line",
      stroke: "var(--background-modifier-border)",
      "stroke-width": 1,
      "stroke-dasharray": "2,2",
      opacity: 0.5
    });
    group.appendChild(line);
  }
  for (const tick of yTicks) {
    const y = yScale(tick);
    const line = createSvgElement("line", {
      x1: 0,
      y1: y,
      x2: inner.width,
      y2: y,
      class: "scatter-grid-line",
      stroke: "var(--background-modifier-border)",
      "stroke-width": 1,
      "stroke-dasharray": "2,2",
      opacity: 0.5
    });
    group.appendChild(line);
  }
  return group;
};
var createChartSvg = (points, bounds, categories, config) => {
  const { viewport, pointConfig, palette, showGrid, xLabel, yLabel } = config;
  const inner = calculateInnerDimensions(viewport);
  const svg = createSvgElement("svg", {
    width: viewport.width,
    height: viewport.height,
    viewBox: `0 0 ${viewport.width} ${viewport.height}`,
    class: "scatter-chart"
  });
  const mainGroup = createSvgElement("g", {
    transform: `translate(${viewport.margin.left}, ${viewport.margin.top})`
  });
  svg.appendChild(mainGroup);
  if (showGrid) {
    mainGroup.appendChild(createGridLines(bounds.x, bounds.y, inner));
  }
  const colorMap = createCategoryColorMap(categories, palette);
  const renderedPoints = transformPointsToScreen(
    points,
    bounds,
    inner,
    colorMap,
    palette
  );
  mainGroup.appendChild(createXAxis(bounds.x, inner, xLabel));
  mainGroup.appendChild(createYAxis(bounds.y, inner, yLabel));
  mainGroup.appendChild(createPointsLayer(renderedPoints, pointConfig));
  return svg;
};
var createEmptyState = (message) => {
  const container = document.createElement("div");
  container.className = "scatter-empty-state";
  const icon = document.createElement("div");
  icon.className = "scatter-empty-state-icon";
  icon.textContent = "\u{1F4CA}";
  container.appendChild(icon);
  const text = document.createElement("div");
  text.className = "scatter-empty-state-text";
  text.textContent = message;
  container.appendChild(text);
  return container;
};
var createSkippedWarning = (count) => {
  const warning = document.createElement("div");
  warning.className = "scatter-skipped-warning";
  warning.style.cssText = `
    position: absolute;
    bottom: 8px;
    right: 8px;
    font-size: 11px;
    color: var(--text-muted);
    background: var(--background-secondary);
    padding: 4px 8px;
    border-radius: 4px;
  `;
  warning.textContent = `${count} note${count === 1 ? "" : "s"} skipped (missing numeric values)`;
  return warning;
};

// src/interactions.ts
var import_obsidian = require("obsidian");
var createPointIndex = (points) => {
  const index = /* @__PURE__ */ new Map();
  for (const point of points) {
    index.set(point.file.path, point);
  }
  return index;
};
var findPointFromElement = (element, pointIndex) => {
  var _a;
  const filePath = element.getAttribute("data-file-path");
  if (filePath === null)
    return null;
  return (_a = pointIndex.get(filePath)) != null ? _a : null;
};
var createClickHandler = (config) => {
  const { app } = config;
  return (point, event) => {
    if (event.button !== 0 && event.button !== 1)
      return;
    event.preventDefault();
    event.stopPropagation();
    const path = point.file.path;
    const modEvent = import_obsidian.Keymap.isModEvent(event);
    void app.workspace.openLinkText(path, "", modEvent);
  };
};
var createHoverHandler = (config) => {
  const { app, hoverParent, source } = config;
  return (point, element, event) => {
    app.workspace.trigger("hover-link", {
      event,
      source,
      hoverParent,
      targetEl: element,
      linktext: point.file.path
    });
  };
};
var applyHoverEffect = (circle, config = DEFAULT_POINT_CONFIG) => {
  circle.setAttribute("r", String(config.hoverRadius));
  circle.setAttribute("opacity", "1");
};
var removeHoverEffect = (circle, config = DEFAULT_POINT_CONFIG) => {
  circle.setAttribute("r", String(config.radius));
  circle.setAttribute("opacity", String(config.opacity));
};
var createTooltip = (data) => {
  const tooltip = document.createElement("div");
  tooltip.className = "scatter-tooltip";
  const title = document.createElement("div");
  title.className = "scatter-tooltip-title";
  title.textContent = data.label;
  tooltip.appendChild(title);
  const formatValue = (v) => v.toLocaleString(void 0, { maximumFractionDigits: 2 });
  const values = document.createElement("div");
  values.className = "scatter-tooltip-values";
  const xLine = document.createElement("div");
  xLine.textContent = `${data.xLabel}: ${formatValue(data.x)}`;
  values.appendChild(xLine);
  const yLine = document.createElement("div");
  yLine.textContent = `${data.yLabel}: ${formatValue(data.y)}`;
  values.appendChild(yLine);
  if (data.category) {
    const categoryLine = document.createElement("div");
    categoryLine.textContent = `Category: ${data.category}`;
    values.appendChild(categoryLine);
  }
  tooltip.appendChild(values);
  return tooltip;
};
var positionTooltip = (tooltip, targetRect, containerRect) => {
  const offset = 12;
  let left = targetRect.right + offset - containerRect.left;
  let top = targetRect.top - containerRect.top;
  const tooltipWidth = tooltip.offsetWidth || 200;
  if (left + tooltipWidth > containerRect.width) {
    left = targetRect.left - tooltipWidth - offset - containerRect.left;
  }
  const tooltipHeight = tooltip.offsetHeight || 80;
  if (top + tooltipHeight > containerRect.height) {
    top = containerRect.height - tooltipHeight - offset;
  }
  left = Math.max(8, left);
  top = Math.max(8, top);
  tooltip.style.left = `${left}px`;
  tooltip.style.top = `${top}px`;
};
var attachPointEvents = (svg, config) => {
  const {
    app,
    hoverParent,
    containerEl,
    pointIndex,
    xLabel,
    yLabel,
    pointConfig
  } = config;
  const clickHandler = createClickHandler({ app });
  const hoverHandler = createHoverHandler({
    app,
    hoverParent,
    source: "scatter-plot"
  });
  let activeTooltip = null;
  const handleMouseEnter = (event) => {
    const target = event.target;
    if (!target.classList.contains("scatter-point"))
      return;
    const point = findPointFromElement(target, pointIndex);
    if (point === null)
      return;
    applyHoverEffect(target, pointConfig);
    hoverHandler(point, target, event);
    if (activeTooltip) {
      activeTooltip.remove();
    }
    activeTooltip = createTooltip({
      label: point.label,
      x: point.x,
      y: point.y,
      xLabel,
      yLabel,
      category: point.category
    });
    containerEl.appendChild(activeTooltip);
    const targetRect = target.getBoundingClientRect();
    const containerRect = containerEl.getBoundingClientRect();
    positionTooltip(activeTooltip, targetRect, containerRect);
  };
  const handleMouseLeave = (event) => {
    const target = event.target;
    if (!target.classList.contains("scatter-point"))
      return;
    removeHoverEffect(target, pointConfig);
    if (activeTooltip) {
      activeTooltip.remove();
      activeTooltip = null;
    }
  };
  const handleClick = (event) => {
    const target = event.target;
    if (!target.classList.contains("scatter-point"))
      return;
    const point = findPointFromElement(target, pointIndex);
    if (point === null)
      return;
    clickHandler(point, event);
  };
  svg.addEventListener("mouseenter", handleMouseEnter, true);
  svg.addEventListener("mouseleave", handleMouseLeave, true);
  svg.addEventListener("click", handleClick);
  return () => {
    svg.removeEventListener("mouseenter", handleMouseEnter, true);
    svg.removeEventListener("mouseleave", handleMouseLeave, true);
    svg.removeEventListener("click", handleClick);
    if (activeTooltip) {
      activeTooltip.remove();
      activeTooltip = null;
    }
  };
};

// src/scatter-view.ts
var SCATTER_VIEW_TYPE = "scatter-plot";
var readConfig = (view) => {
  const xAxis = view.config.get("xAxis");
  const yAxis = view.config.get("yAxis");
  const colorBy = view.config.get("colorBy");
  return {
    xAxis: typeof xAxis === "string" && xAxis.length > 0 ? xAxis : null,
    yAxis: typeof yAxis === "string" && yAxis.length > 0 ? yAxis : null,
    colorBy: typeof colorBy === "string" && colorBy.length > 0 ? colorBy : null
  };
};
var propertyIdToLabel = (propertyId) => {
  if (propertyId === null)
    return "";
  const parts = propertyId.split(".");
  const name = parts.length > 1 ? parts.slice(1).join(".") : propertyId;
  return name.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/_/g, " ").replace(/^\w/, (c) => c.toUpperCase());
};
var ScatterPlotView = class extends import_obsidian2.BasesView {
  constructor(controller, parentEl) {
    super(controller);
    /** Required by BasesView */
    this.type = SCATTER_VIEW_TYPE;
    /** Required by HoverParent */
    this.hoverPopover = null;
    /** Cleanup function for event listeners */
    this.cleanup = null;
    /** Current viewport dimensions */
    this.viewport = DEFAULT_VIEWPORT;
    /** Cached rendered points for interaction lookups */
    this.renderedPoints = [];
    this.resizeTimeout = null;
    this.containerEl = parentEl.createDiv({
      cls: "scatter-plot-container"
    });
    this.containerEl.style.cssText = `
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    `;
    this.setupResizeObserver();
  }
  /**
   * Called by Obsidian when data or configuration changes.
   * This is the main render entry point.
   */
  onDataUpdated() {
    var _a;
    (_a = this.cleanup) == null ? void 0 : _a.call(this);
    this.cleanup = null;
    this.containerEl.empty();
    const config = readConfig(this);
    if (config.xAxis === null || config.yAxis === null) {
      this.renderEmptyState(
        "Configure X and Y axis properties in the view settings to display the scatter plot."
      );
      return;
    }
    const entries = flattenGroupedData(this.data.groupedData);
    const extraction = extractDataFromEntries(entries, config);
    if (extraction.points.length === 0) {
      const message = extraction.skipped.length > 0 ? `No plottable points. ${extraction.skipped.length} note${extraction.skipped.length === 1 ? "" : "s"} skipped due to missing or non-numeric values.` : "No notes match the current filters.";
      this.renderEmptyState(message);
      return;
    }
    const bounds = calculatePlotBounds(extraction.points);
    if (bounds === null) {
      this.renderEmptyState("Unable to calculate plot bounds.");
      return;
    }
    this.renderChart(config, extraction, bounds);
  }
  /**
   * Renders the empty state message.
   */
  renderEmptyState(message) {
    const emptyState = createEmptyState(message);
    this.containerEl.appendChild(emptyState);
  }
  /**
   * Renders the full scatter plot chart.
   */
  renderChart(config, extraction, bounds) {
    const { points, skipped, categories } = extraction;
    this.updateViewportFromContainer();
    const xLabel = propertyIdToLabel(config.xAxis);
    const yLabel = propertyIdToLabel(config.yAxis);
    const svg = createChartSvg(points, bounds, categories, {
      viewport: this.viewport,
      pointConfig: DEFAULT_POINT_CONFIG,
      palette: DEFAULT_PALETTE,
      showGrid: true,
      xLabel,
      yLabel
    });
    this.containerEl.appendChild(svg);
    const inner = calculateInnerDimensions(this.viewport);
    const colorMap = createCategoryColorMap(categories, DEFAULT_PALETTE);
    this.renderedPoints = transformPointsToScreen(
      points,
      bounds,
      inner,
      colorMap,
      DEFAULT_PALETTE
    );
    const pointIndex = createPointIndex(this.renderedPoints);
    this.cleanup = attachPointEvents(svg, {
      app: this.app,
      hoverParent: this,
      containerEl: this.containerEl,
      pointIndex,
      xLabel,
      yLabel,
      pointConfig: DEFAULT_POINT_CONFIG
    });
    if (skipped.length > 0) {
      const warning = createSkippedWarning(skipped.length);
      this.containerEl.appendChild(warning);
    }
  }
  /**
   * Updates viewport dimensions from the container element.
   */
  updateViewportFromContainer() {
    const rect = this.containerEl.getBoundingClientRect();
    const width = rect.width > 100 ? rect.width : DEFAULT_VIEWPORT.width;
    const height = rect.height > 100 ? rect.height : DEFAULT_VIEWPORT.height;
    this.viewport = {
      ...DEFAULT_VIEWPORT,
      width,
      height
    };
  }
  /**
   * Sets up a ResizeObserver to re-render when container size changes.
   */
  setupResizeObserver() {
    const observer = new ResizeObserver(() => {
      if (this.resizeTimeout !== null) {
        window.clearTimeout(this.resizeTimeout);
      }
      this.resizeTimeout = window.setTimeout(() => {
        this.onDataUpdated();
      }, 100);
    });
    observer.observe(this.containerEl);
    this.register(() => {
      observer.disconnect();
      if (this.resizeTimeout !== null) {
        window.clearTimeout(this.resizeTimeout);
      }
    });
  }
  /**
   * Cleanup when the view is unloaded.
   */
  onunload() {
    var _a;
    (_a = this.cleanup) == null ? void 0 : _a.call(this);
    this.cleanup = null;
  }
};

// src/main.ts
var ScatterPlotPlugin = class extends import_obsidian3.Plugin {
  onload() {
    console.debug("Loading Scatter Plot plugin");
    this.registerBasesView(SCATTER_VIEW_TYPE, {
      name: "Scatter Plot",
      icon: "lucide-scatter-chart",
      factory: (controller, containerEl) => {
        return new ScatterPlotView(controller, containerEl);
      },
      options: () => [
        {
          type: "property",
          key: "xAxis",
          displayName: "X axis"
          // Note: The 'property' type may need to be verified against
          // the actual ViewOption types available in the API.
          // If 'property' isn't available, fall back to 'text'.
        },
        {
          type: "property",
          key: "yAxis",
          displayName: "Y axis"
        },
        {
          type: "property",
          key: "colorBy",
          displayName: "Color by (optional)"
        }
        // Future options:
        // {
        //   type: "property",
        //   key: "sizeBy",
        //   displayName: "Size by (optional)",
        // },
        // {
        //   type: "toggle",
        //   key: "showGrid",
        //   displayName: "Show grid lines",
        //   default: true,
        // },
        // {
        //   type: "slider",
        //   key: "pointRadius",
        //   displayName: "Point size",
        //   default: 8,
        //   min: 4,
        //   max: 20,
        // },
      ]
    });
  }
  onunload() {
    console.debug("Unloading Scatter Plot plugin");
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3NjYXR0ZXItdmlldy50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL2RhdGEudHMiLCAic3JjL3JlbmRlci50cyIsICJzcmMvaW50ZXJhY3Rpb25zLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIE9ic2lkaWFuIEJhc2VzIFNjYXR0ZXIgUGxvdCBQbHVnaW5cbiAqXG4gKiBBZGRzIGEgc2NhdHRlciBwbG90IHZpZXcgdHlwZSB0byBPYnNpZGlhbiBCYXNlcyBmb3IgdmlzdWFsaXppbmdcbiAqIG5vdGVzIGFsb25nIHR3byBudW1lcmljIHByb3BlcnR5IGF4ZXMuXG4gKi9cblxuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBTY2F0dGVyUGxvdFZpZXcsIFNDQVRURVJfVklFV19UWVBFIH0gZnJvbSBcIi4vc2NhdHRlci12aWV3XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJQbG90UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgb25sb2FkKCk6IHZvaWQge1xuICAgIGNvbnNvbGUuZGVidWcoXCJMb2FkaW5nIFNjYXR0ZXIgUGxvdCBwbHVnaW5cIik7XG5cbiAgICB0aGlzLnJlZ2lzdGVyQmFzZXNWaWV3KFNDQVRURVJfVklFV19UWVBFLCB7XG4gICAgICBuYW1lOiBcIlNjYXR0ZXIgUGxvdFwiLFxuICAgICAgaWNvbjogXCJsdWNpZGUtc2NhdHRlci1jaGFydFwiLFxuXG4gICAgICBmYWN0b3J5OiAoY29udHJvbGxlciwgY29udGFpbmVyRWwpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2F0dGVyUGxvdFZpZXcoY29udHJvbGxlciwgY29udGFpbmVyRWwpO1xuICAgICAgfSxcblxuICAgICAgb3B0aW9uczogKCkgPT4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eVwiLFxuICAgICAgICAgIGtleTogXCJ4QXhpc1wiLFxuICAgICAgICAgIGRpc3BsYXlOYW1lOiBcIlggYXhpc1wiLFxuICAgICAgICAgIC8vIE5vdGU6IFRoZSAncHJvcGVydHknIHR5cGUgbWF5IG5lZWQgdG8gYmUgdmVyaWZpZWQgYWdhaW5zdFxuICAgICAgICAgIC8vIHRoZSBhY3R1YWwgVmlld09wdGlvbiB0eXBlcyBhdmFpbGFibGUgaW4gdGhlIEFQSS5cbiAgICAgICAgICAvLyBJZiAncHJvcGVydHknIGlzbid0IGF2YWlsYWJsZSwgZmFsbCBiYWNrIHRvICd0ZXh0Jy5cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwicHJvcGVydHlcIixcbiAgICAgICAgICBrZXk6IFwieUF4aXNcIixcbiAgICAgICAgICBkaXNwbGF5TmFtZTogXCJZIGF4aXNcIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwicHJvcGVydHlcIixcbiAgICAgICAgICBrZXk6IFwiY29sb3JCeVwiLFxuICAgICAgICAgIGRpc3BsYXlOYW1lOiBcIkNvbG9yIGJ5IChvcHRpb25hbClcIixcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRnV0dXJlIG9wdGlvbnM6XG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICB0eXBlOiBcInByb3BlcnR5XCIsXG4gICAgICAgIC8vICAga2V5OiBcInNpemVCeVwiLFxuICAgICAgICAvLyAgIGRpc3BsYXlOYW1lOiBcIlNpemUgYnkgKG9wdGlvbmFsKVwiLFxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgdHlwZTogXCJ0b2dnbGVcIixcbiAgICAgICAgLy8gICBrZXk6IFwic2hvd0dyaWRcIixcbiAgICAgICAgLy8gICBkaXNwbGF5TmFtZTogXCJTaG93IGdyaWQgbGluZXNcIixcbiAgICAgICAgLy8gICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgdHlwZTogXCJzbGlkZXJcIixcbiAgICAgICAgLy8gICBrZXk6IFwicG9pbnRSYWRpdXNcIixcbiAgICAgICAgLy8gICBkaXNwbGF5TmFtZTogXCJQb2ludCBzaXplXCIsXG4gICAgICAgIC8vICAgZGVmYXVsdDogOCxcbiAgICAgICAgLy8gICBtaW46IDQsXG4gICAgICAgIC8vICAgbWF4OiAyMCxcbiAgICAgICAgLy8gfSxcbiAgICAgIF0sXG4gICAgfSk7XG4gIH1cblxuICBvbnVubG9hZCgpOiB2b2lkIHtcbiAgICBjb25zb2xlLmRlYnVnKFwiVW5sb2FkaW5nIFNjYXR0ZXIgUGxvdCBwbHVnaW5cIik7XG4gIH1cbn1cbiIsICIvKipcbiAqIFNjYXR0ZXJQbG90VmlldyAtIFRoZSBtYWluIEJhc2VzIHZpZXcgaW1wbGVtZW50YXRpb24uXG4gKlxuICogRXh0ZW5kcyBCYXNlc1ZpZXcgYW5kIG9yY2hlc3RyYXRlcyBkYXRhIGV4dHJhY3Rpb24sIHJlbmRlcmluZywgYW5kIGludGVyYWN0aW9ucy5cbiAqL1xuXG5pbXBvcnQge1xuICBCYXNlc1ZpZXcsXG4gIHR5cGUgUXVlcnlDb250cm9sbGVyLFxuICB0eXBlIEhvdmVyUGFyZW50LFxuICB0eXBlIEhvdmVyUG9wb3Zlcixcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgdHlwZSB7XG4gIFNjYXR0ZXJDb25maWcsXG4gIERhdGFFeHRyYWN0aW9uUmVzdWx0LFxuICBQbG90Qm91bmRzLFxuICBWaWV3cG9ydERpbWVuc2lvbnMsXG4gIFJlbmRlcmVkUG9pbnQsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQge1xuICBERUZBVUxUX1ZJRVdQT1JULFxuICBERUZBVUxUX1BBTEVUVEUsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQge1xuICBleHRyYWN0RGF0YUZyb21FbnRyaWVzLFxuICBmbGF0dGVuR3JvdXBlZERhdGEsXG4gIGNhbGN1bGF0ZVBsb3RCb3VuZHMsXG59IGZyb20gXCIuL2RhdGFcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUNoYXJ0U3ZnLFxuICBjcmVhdGVFbXB0eVN0YXRlLFxuICBjcmVhdGVTa2lwcGVkV2FybmluZyxcbiAgY2FsY3VsYXRlSW5uZXJEaW1lbnNpb25zLFxuICB0cmFuc2Zvcm1Qb2ludHNUb1NjcmVlbixcbiAgY3JlYXRlQ2F0ZWdvcnlDb2xvck1hcCxcbiAgREVGQVVMVF9QT0lOVF9DT05GSUcsXG59IGZyb20gXCIuL3JlbmRlclwiO1xuaW1wb3J0IHtcbiAgYXR0YWNoUG9pbnRFdmVudHMsXG4gIGNyZWF0ZVBvaW50SW5kZXgsXG59IGZyb20gXCIuL2ludGVyYWN0aW9uc1wiO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBWaWV3IFR5cGUgSWRlbnRpZmllclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY29uc3QgU0NBVFRFUl9WSUVXX1RZUEUgPSBcInNjYXR0ZXItcGxvdFwiIGFzIGNvbnN0O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDb25maWd1cmF0aW9uIEhlbHBlcnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBSZWFkcyB0aGUgc2NhdHRlciBjb25maWcgZnJvbSB0aGUgdmlldyBjb25maWcuXG4gKiBSZXR1cm5zIGRlZmF1bHRzIGZvciBtaXNzaW5nIHZhbHVlcy5cbiAqL1xuY29uc3QgcmVhZENvbmZpZyA9ICh2aWV3OiBTY2F0dGVyUGxvdFZpZXcpOiBTY2F0dGVyQ29uZmlnID0+IHtcbiAgY29uc3QgeEF4aXMgPSB2aWV3LmNvbmZpZy5nZXQoXCJ4QXhpc1wiKTtcbiAgY29uc3QgeUF4aXMgPSB2aWV3LmNvbmZpZy5nZXQoXCJ5QXhpc1wiKTtcbiAgY29uc3QgY29sb3JCeSA9IHZpZXcuY29uZmlnLmdldChcImNvbG9yQnlcIik7XG5cbiAgcmV0dXJuIHtcbiAgICB4QXhpczogdHlwZW9mIHhBeGlzID09PSBcInN0cmluZ1wiICYmIHhBeGlzLmxlbmd0aCA+IDAgPyB4QXhpcyA6IG51bGwsXG4gICAgeUF4aXM6IHR5cGVvZiB5QXhpcyA9PT0gXCJzdHJpbmdcIiAmJiB5QXhpcy5sZW5ndGggPiAwID8geUF4aXMgOiBudWxsLFxuICAgIGNvbG9yQnk6IHR5cGVvZiBjb2xvckJ5ID09PSBcInN0cmluZ1wiICYmIGNvbG9yQnkubGVuZ3RoID4gMCA/IGNvbG9yQnkgOiBudWxsLFxuICB9O1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyBhIGh1bWFuLXJlYWRhYmxlIGxhYmVsIGZyb20gYSBwcm9wZXJ0eSBJRC5cbiAqIFByb3BlcnR5IElEcyBjYW4gYmUgbGlrZSBcInByb3BlcnR5LmVmZm9ydFwiIG9yIFwiZm9ybXVsYS5jb21wdXRlZF9zY29yZVwiXG4gKi9cbmNvbnN0IHByb3BlcnR5SWRUb0xhYmVsID0gKHByb3BlcnR5SWQ6IHN0cmluZyB8IG51bGwpOiBzdHJpbmcgPT4ge1xuICBpZiAocHJvcGVydHlJZCA9PT0gbnVsbCkgcmV0dXJuIFwiXCI7XG5cbiAgLy8gUmVtb3ZlIHByZWZpeCBsaWtlIFwicHJvcGVydHkuXCIgb3IgXCJmb3JtdWxhLlwiXG4gIGNvbnN0IHBhcnRzID0gcHJvcGVydHlJZC5zcGxpdChcIi5cIik7XG4gIGNvbnN0IG5hbWUgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHMuc2xpY2UoMSkuam9pbihcIi5cIikgOiBwcm9wZXJ0eUlkO1xuXG4gIC8vIENvbnZlcnQgc25ha2VfY2FzZSBvciBjYW1lbENhc2UgdG8gVGl0bGUgQ2FzZVxuICByZXR1cm4gbmFtZVxuICAgIC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxICQyXCIpXG4gICAgLnJlcGxhY2UoL18vZywgXCIgXCIpXG4gICAgLnJlcGxhY2UoL15cXHcvLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNjYXR0ZXJQbG90VmlldyBDbGFzc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY2xhc3MgU2NhdHRlclBsb3RWaWV3IGV4dGVuZHMgQmFzZXNWaWV3IGltcGxlbWVudHMgSG92ZXJQYXJlbnQge1xuICAvKiogUmVxdWlyZWQgYnkgQmFzZXNWaWV3ICovXG4gIHB1YmxpYyByZWFkb25seSB0eXBlID0gU0NBVFRFUl9WSUVXX1RZUEU7XG5cbiAgLyoqIFJlcXVpcmVkIGJ5IEhvdmVyUGFyZW50ICovXG4gIHB1YmxpYyBob3ZlclBvcG92ZXI6IEhvdmVyUG9wb3ZlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKiBUaGUgY29udGFpbmVyIGVsZW1lbnQgZm9yIHJlbmRlcmluZyAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudDtcblxuICAvKiogQ2xlYW51cCBmdW5jdGlvbiBmb3IgZXZlbnQgbGlzdGVuZXJzICovXG4gIHByaXZhdGUgY2xlYW51cDogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqIEN1cnJlbnQgdmlld3BvcnQgZGltZW5zaW9ucyAqL1xuICBwcml2YXRlIHZpZXdwb3J0OiBWaWV3cG9ydERpbWVuc2lvbnMgPSBERUZBVUxUX1ZJRVdQT1JUO1xuXG4gIC8qKiBDYWNoZWQgcmVuZGVyZWQgcG9pbnRzIGZvciBpbnRlcmFjdGlvbiBsb29rdXBzICovXG4gIHByaXZhdGUgcmVuZGVyZWRQb2ludHM6IHJlYWRvbmx5IFJlbmRlcmVkUG9pbnRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXI6IFF1ZXJ5Q29udHJvbGxlciwgcGFyZW50RWw6IEhUTUxFbGVtZW50KSB7XG4gICAgc3VwZXIoY29udHJvbGxlcik7XG5cbiAgICAvLyBDcmVhdGUgY29udGFpbmVyIHdpdGggcmVsYXRpdmUgcG9zaXRpb25pbmcgZm9yIHRvb2x0aXBzXG4gICAgdGhpcy5jb250YWluZXJFbCA9IHBhcmVudEVsLmNyZWF0ZURpdih7XG4gICAgICBjbHM6IFwic2NhdHRlci1wbG90LWNvbnRhaW5lclwiLFxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyRWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBgO1xuXG4gICAgLy8gU2V0IHVwIHJlc2l6ZSBvYnNlcnZlciB0byB0cmFjayBjb250YWluZXIgc2l6ZVxuICAgIHRoaXMuc2V0dXBSZXNpemVPYnNlcnZlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSBPYnNpZGlhbiB3aGVuIGRhdGEgb3IgY29uZmlndXJhdGlvbiBjaGFuZ2VzLlxuICAgKiBUaGlzIGlzIHRoZSBtYWluIHJlbmRlciBlbnRyeSBwb2ludC5cbiAgICovXG4gIHB1YmxpYyBvbkRhdGFVcGRhdGVkKCk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIHByZXZpb3VzIHJlbmRlclxuICAgIHRoaXMuY2xlYW51cD8uKCk7XG4gICAgdGhpcy5jbGVhbnVwID0gbnVsbDtcbiAgICB0aGlzLmNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAvLyBSZWFkIGNvbmZpZ3VyYXRpb25cbiAgICBjb25zdCBjb25maWcgPSByZWFkQ29uZmlnKHRoaXMpO1xuXG4gICAgLy8gQ2hlY2sgaWYgYXhlcyBhcmUgY29uZmlndXJlZFxuICAgIGlmIChjb25maWcueEF4aXMgPT09IG51bGwgfHwgY29uZmlnLnlBeGlzID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJlbmRlckVtcHR5U3RhdGUoXG4gICAgICAgIFwiQ29uZmlndXJlIFggYW5kIFkgYXhpcyBwcm9wZXJ0aWVzIGluIHRoZSB2aWV3IHNldHRpbmdzIHRvIGRpc3BsYXkgdGhlIHNjYXR0ZXIgcGxvdC5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IGRhdGEgZnJvbSBlbnRyaWVzXG4gICAgY29uc3QgZW50cmllcyA9IGZsYXR0ZW5Hcm91cGVkRGF0YSh0aGlzLmRhdGEuZ3JvdXBlZERhdGEpO1xuICAgIGNvbnN0IGV4dHJhY3Rpb24gPSBleHRyYWN0RGF0YUZyb21FbnRyaWVzKGVudHJpZXMsIGNvbmZpZyk7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFueSBwbG90dGFibGUgcG9pbnRzXG4gICAgaWYgKGV4dHJhY3Rpb24ucG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgIGV4dHJhY3Rpb24uc2tpcHBlZC5sZW5ndGggPiAwXG4gICAgICAgICAgPyBgTm8gcGxvdHRhYmxlIHBvaW50cy4gJHtleHRyYWN0aW9uLnNraXBwZWQubGVuZ3RofSBub3RlJHtleHRyYWN0aW9uLnNraXBwZWQubGVuZ3RoID09PSAxID8gXCJcIiA6IFwic1wifSBza2lwcGVkIGR1ZSB0byBtaXNzaW5nIG9yIG5vbi1udW1lcmljIHZhbHVlcy5gXG4gICAgICAgICAgOiBcIk5vIG5vdGVzIG1hdGNoIHRoZSBjdXJyZW50IGZpbHRlcnMuXCI7XG4gICAgICB0aGlzLnJlbmRlckVtcHR5U3RhdGUobWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGJvdW5kc1xuICAgIGNvbnN0IGJvdW5kcyA9IGNhbGN1bGF0ZVBsb3RCb3VuZHMoZXh0cmFjdGlvbi5wb2ludHMpO1xuICAgIGlmIChib3VuZHMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMucmVuZGVyRW1wdHlTdGF0ZShcIlVuYWJsZSB0byBjYWxjdWxhdGUgcGxvdCBib3VuZHMuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciB0aGUgY2hhcnRcbiAgICB0aGlzLnJlbmRlckNoYXJ0KGNvbmZpZywgZXh0cmFjdGlvbiwgYm91bmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBlbXB0eSBzdGF0ZSBtZXNzYWdlLlxuICAgKi9cbiAgcHJpdmF0ZSByZW5kZXJFbXB0eVN0YXRlKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGVtcHR5U3RhdGUgPSBjcmVhdGVFbXB0eVN0YXRlKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQoZW1wdHlTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZnVsbCBzY2F0dGVyIHBsb3QgY2hhcnQuXG4gICAqL1xuICBwcml2YXRlIHJlbmRlckNoYXJ0KFxuICAgIGNvbmZpZzogU2NhdHRlckNvbmZpZyxcbiAgICBleHRyYWN0aW9uOiBEYXRhRXh0cmFjdGlvblJlc3VsdCxcbiAgICBib3VuZHM6IFBsb3RCb3VuZHNcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgeyBwb2ludHMsIHNraXBwZWQsIGNhdGVnb3JpZXMgfSA9IGV4dHJhY3Rpb247XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnQgZGltZW5zaW9ucyBmcm9tIGNvbnRhaW5lclxuICAgIHRoaXMudXBkYXRlVmlld3BvcnRGcm9tQ29udGFpbmVyKCk7XG5cbiAgICAvLyBMYWJlbHMgZm9yIGF4ZXNcbiAgICBjb25zdCB4TGFiZWwgPSBwcm9wZXJ0eUlkVG9MYWJlbChjb25maWcueEF4aXMpO1xuICAgIGNvbnN0IHlMYWJlbCA9IHByb3BlcnR5SWRUb0xhYmVsKGNvbmZpZy55QXhpcyk7XG5cbiAgICAvLyBDcmVhdGUgU1ZHXG4gICAgY29uc3Qgc3ZnID0gY3JlYXRlQ2hhcnRTdmcocG9pbnRzLCBib3VuZHMsIGNhdGVnb3JpZXMsIHtcbiAgICAgIHZpZXdwb3J0OiB0aGlzLnZpZXdwb3J0LFxuICAgICAgcG9pbnRDb25maWc6IERFRkFVTFRfUE9JTlRfQ09ORklHLFxuICAgICAgcGFsZXR0ZTogREVGQVVMVF9QQUxFVFRFLFxuICAgICAgc2hvd0dyaWQ6IHRydWUsXG4gICAgICB4TGFiZWwsXG4gICAgICB5TGFiZWwsXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lckVsLmFwcGVuZENoaWxkKHN2Zyk7XG5cbiAgICAvLyBDYWNoZSByZW5kZXJlZCBwb2ludHMgZm9yIGludGVyYWN0aW9uIGxvb2t1cHNcbiAgICBjb25zdCBpbm5lciA9IGNhbGN1bGF0ZUlubmVyRGltZW5zaW9ucyh0aGlzLnZpZXdwb3J0KTtcbiAgICBjb25zdCBjb2xvck1hcCA9IGNyZWF0ZUNhdGVnb3J5Q29sb3JNYXAoY2F0ZWdvcmllcywgREVGQVVMVF9QQUxFVFRFKTtcbiAgICB0aGlzLnJlbmRlcmVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzVG9TY3JlZW4oXG4gICAgICBwb2ludHMsXG4gICAgICBib3VuZHMsXG4gICAgICBpbm5lcixcbiAgICAgIGNvbG9yTWFwLFxuICAgICAgREVGQVVMVF9QQUxFVFRFXG4gICAgKTtcblxuICAgIC8vIEF0dGFjaCBldmVudCBoYW5kbGVyc1xuICAgIGNvbnN0IHBvaW50SW5kZXggPSBjcmVhdGVQb2ludEluZGV4KHRoaXMucmVuZGVyZWRQb2ludHMpO1xuICAgIHRoaXMuY2xlYW51cCA9IGF0dGFjaFBvaW50RXZlbnRzKHN2Zywge1xuICAgICAgYXBwOiB0aGlzLmFwcCxcbiAgICAgIGhvdmVyUGFyZW50OiB0aGlzLFxuICAgICAgY29udGFpbmVyRWw6IHRoaXMuY29udGFpbmVyRWwsXG4gICAgICBwb2ludEluZGV4LFxuICAgICAgeExhYmVsLFxuICAgICAgeUxhYmVsLFxuICAgICAgcG9pbnRDb25maWc6IERFRkFVTFRfUE9JTlRfQ09ORklHLFxuICAgIH0pO1xuXG4gICAgLy8gU2hvdyB3YXJuaW5nIGFib3V0IHNraXBwZWQgZW50cmllc1xuICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHdhcm5pbmcgPSBjcmVhdGVTa2lwcGVkV2FybmluZyhza2lwcGVkLmxlbmd0aCk7XG4gICAgICB0aGlzLmNvbnRhaW5lckVsLmFwcGVuZENoaWxkKHdhcm5pbmcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHZpZXdwb3J0IGRpbWVuc2lvbnMgZnJvbSB0aGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZVZpZXdwb3J0RnJvbUNvbnRhaW5lcigpOiB2b2lkIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5jb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIC8vIFVzZSBjb250YWluZXIgc2l6ZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gZGVmYXVsdHNcbiAgICBjb25zdCB3aWR0aCA9IHJlY3Qud2lkdGggPiAxMDAgPyByZWN0LndpZHRoIDogREVGQVVMVF9WSUVXUE9SVC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0LmhlaWdodCA+IDEwMCA/IHJlY3QuaGVpZ2h0IDogREVGQVVMVF9WSUVXUE9SVC5oZWlnaHQ7XG5cbiAgICB0aGlzLnZpZXdwb3J0ID0ge1xuICAgICAgLi4uREVGQVVMVF9WSUVXUE9SVCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCBhIFJlc2l6ZU9ic2VydmVyIHRvIHJlLXJlbmRlciB3aGVuIGNvbnRhaW5lciBzaXplIGNoYW5nZXMuXG4gICAqL1xuICBwcml2YXRlIHNldHVwUmVzaXplT2JzZXJ2ZXIoKTogdm9pZCB7XG4gICAgLy8gVXNlIE9ic2lkaWFuJ3MgQ29tcG9uZW50LnJlZ2lzdGVyIGZvciBjbGVhbnVwXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgLy8gRGVib3VuY2UgcmVzaXplIGV2ZW50c1xuICAgICAgaWYgKHRoaXMucmVzaXplVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub25EYXRhVXBkYXRlZCgpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9KTtcblxuICAgIG9ic2VydmVyLm9ic2VydmUodGhpcy5jb250YWluZXJFbCk7XG5cbiAgICAvLyBSZWdpc3RlciBjbGVhbnVwXG4gICAgdGhpcy5yZWdpc3RlcigoKSA9PiB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBpZiAodGhpcy5yZXNpemVUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzaXplVGltZW91dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIENsZWFudXAgd2hlbiB0aGUgdmlldyBpcyB1bmxvYWRlZC5cbiAgICovXG4gIHB1YmxpYyBvbnVubG9hZCgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFudXA/LigpO1xuICAgIHRoaXMuY2xlYW51cCA9IG51bGw7XG4gIH1cbn1cbiIsICIvKipcbiAqIFR5cGUgZGVmaW5pdGlvbnMgZm9yIG9ic2lkaWFuLWJhc2VzLXNjYXR0ZXIgcGx1Z2luXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBCYXNlc0VudHJ5LCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDb25maWd1cmF0aW9uIFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKiBLZXlzIHVzZWQgaW4gdmlldyBjb25maWd1cmF0aW9uIHN0b3JhZ2UgKi9cbmV4cG9ydCB0eXBlIENvbmZpZ0tleSA9IFwieEF4aXNcIiB8IFwieUF4aXNcIiB8IFwiY29sb3JCeVwiO1xuXG4vKiogVGhlIHJhdyBjb25maWd1cmF0aW9uIHZhbHVlcyBzdG9yZWQgaW4gLmJhc2UgZmlsZSAqL1xuZXhwb3J0IGludGVyZmFjZSBTY2F0dGVyQ29uZmlnIHtcbiAgcmVhZG9ubHkgeEF4aXM6IHN0cmluZyB8IG51bGw7XG4gIHJlYWRvbmx5IHlBeGlzOiBzdHJpbmcgfCBudWxsO1xuICByZWFkb25seSBjb2xvckJ5OiBzdHJpbmcgfCBudWxsO1xufVxuXG4vKiogRGVmYXVsdCBjb25maWd1cmF0aW9uIHZhbHVlcyAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ09ORklHOiBTY2F0dGVyQ29uZmlnID0ge1xuICB4QXhpczogbnVsbCxcbiAgeUF4aXM6IG51bGwsXG4gIGNvbG9yQnk6IG51bGwsXG59IGFzIGNvbnN0O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEYXRhIFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKiBBIHNpbmdsZSBwb2ludCB0aGF0IGNhbiBiZSByZW5kZXJlZCBvbiB0aGUgc2NhdHRlciBwbG90ICovXG5leHBvcnQgaW50ZXJmYWNlIFNjYXR0ZXJQb2ludCB7XG4gIHJlYWRvbmx5IHg6IG51bWJlcjtcbiAgcmVhZG9ubHkgeTogbnVtYmVyO1xuICByZWFkb25seSBjYXRlZ29yeTogc3RyaW5nIHwgbnVsbDtcbiAgcmVhZG9ubHkgbGFiZWw6IHN0cmluZztcbiAgcmVhZG9ubHkgZmlsZTogVEZpbGU7XG4gIHJlYWRvbmx5IGVudHJ5OiBCYXNlc0VudHJ5O1xufVxuXG4vKiogUmVzdWx0IG9mIGV4dHJhY3RpbmcgYSBudW1lcmljIHZhbHVlIGZyb20gYW4gZW50cnkgKi9cbmV4cG9ydCB0eXBlIE51bWVyaWNFeHRyYWN0aW9uUmVzdWx0ID1cbiAgfCB7IHJlYWRvbmx5IHN1Y2Nlc3M6IHRydWU7IHJlYWRvbmx5IHZhbHVlOiBudW1iZXIgfVxuICB8IHsgcmVhZG9ubHkgc3VjY2VzczogZmFsc2U7IHJlYWRvbmx5IHJlYXNvbjogc3RyaW5nIH07XG5cbi8qKiBSZXN1bHQgb2YgZXh0cmFjdGluZyBhIGNhdGVnb3JpY2FsIHZhbHVlIGZyb20gYW4gZW50cnkgKi9cbmV4cG9ydCB0eXBlIENhdGVnb3J5RXh0cmFjdGlvblJlc3VsdCA9XG4gIHwgeyByZWFkb25seSBzdWNjZXNzOiB0cnVlOyByZWFkb25seSB2YWx1ZTogc3RyaW5nIH1cbiAgfCB7IHJlYWRvbmx5IHN1Y2Nlc3M6IGZhbHNlIH07XG5cbi8qKiBSZXN1bHQgb2YgcHJvY2Vzc2luZyBhbGwgZW50cmllcyBpbnRvIHBsb3R0YWJsZSBwb2ludHMgKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUV4dHJhY3Rpb25SZXN1bHQge1xuICByZWFkb25seSBwb2ludHM6IHJlYWRvbmx5IFNjYXR0ZXJQb2ludFtdO1xuICByZWFkb25seSBza2lwcGVkOiByZWFkb25seSBTa2lwcGVkRW50cnlbXTtcbiAgcmVhZG9ubHkgY2F0ZWdvcmllczogcmVhZG9ubHkgc3RyaW5nW107XG59XG5cbi8qKiBBbiBlbnRyeSB0aGF0IHdhcyBza2lwcGVkIGR1cmluZyBleHRyYWN0aW9uIHdpdGggcmVhc29uICovXG5leHBvcnQgaW50ZXJmYWNlIFNraXBwZWRFbnRyeSB7XG4gIHJlYWRvbmx5IGZpbGU6IFRGaWxlO1xuICByZWFkb25seSByZWFzb246IHN0cmluZztcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQXhpcyAvIEJvdW5kcyBUeXBlc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKiogTnVtZXJpYyBib3VuZHMgZm9yIGFuIGF4aXMgKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXhpc0JvdW5kcyB7XG4gIHJlYWRvbmx5IG1pbjogbnVtYmVyO1xuICByZWFkb25seSBtYXg6IG51bWJlcjtcbn1cblxuLyoqIEJvdW5kcyBmb3IgYm90aCBheGVzICovXG5leHBvcnQgaW50ZXJmYWNlIFBsb3RCb3VuZHMge1xuICByZWFkb25seSB4OiBBeGlzQm91bmRzO1xuICByZWFkb25seSB5OiBBeGlzQm91bmRzO1xufVxuXG4vKiogRGltZW5zaW9ucyBmb3IgdGhlIFNWRyB2aWV3cG9ydCAqL1xuZXhwb3J0IGludGVyZmFjZSBWaWV3cG9ydERpbWVuc2lvbnMge1xuICByZWFkb25seSB3aWR0aDogbnVtYmVyO1xuICByZWFkb25seSBoZWlnaHQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgbWFyZ2luOiB7XG4gICAgcmVhZG9ubHkgdG9wOiBudW1iZXI7XG4gICAgcmVhZG9ubHkgcmlnaHQ6IG51bWJlcjtcbiAgICByZWFkb25seSBib3R0b206IG51bWJlcjtcbiAgICByZWFkb25seSBsZWZ0OiBudW1iZXI7XG4gIH07XG59XG5cbi8qKiBDb21wdXRlZCBpbm5lciBkaW1lbnNpb25zICh2aWV3cG9ydCBtaW51cyBtYXJnaW5zKSAqL1xuZXhwb3J0IGludGVyZmFjZSBJbm5lckRpbWVuc2lvbnMge1xuICByZWFkb25seSB3aWR0aDogbnVtYmVyO1xuICByZWFkb25seSBoZWlnaHQ6IG51bWJlcjtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUmVuZGVyaW5nIFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKiBBIHBvaW50IHdpdGggc2NyZWVuIGNvb3JkaW5hdGVzIHJlYWR5IGZvciByZW5kZXJpbmcgKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyZWRQb2ludCBleHRlbmRzIFNjYXR0ZXJQb2ludCB7XG4gIHJlYWRvbmx5IHNjcmVlblg6IG51bWJlcjtcbiAgcmVhZG9ubHkgc2NyZWVuWTogbnVtYmVyO1xuICByZWFkb25seSBjb2xvcjogc3RyaW5nO1xufVxuXG4vKiogQ29sb3IgcGFsZXR0ZSBmb3IgY2F0ZWdvcmllcyAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2xvclBhbGV0dGUge1xuICByZWFkb25seSBmYWxsYmFjazogc3RyaW5nO1xuICByZWFkb25seSBjb2xvcnM6IHJlYWRvbmx5IHN0cmluZ1tdO1xufVxuXG4vKiogRGVmYXVsdCBjb2xvciBwYWxldHRlIHVzaW5nIE9ic2lkaWFuIENTUyB2YXJpYWJsZXMgd2hlcmUgcG9zc2libGUgKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1BBTEVUVEU6IENvbG9yUGFsZXR0ZSA9IHtcbiAgZmFsbGJhY2s6IFwidmFyKC0tdGV4dC1tdXRlZClcIixcbiAgY29sb3JzOiBbXG4gICAgXCJ2YXIoLS1jb2xvci1ibHVlKVwiLFxuICAgIFwidmFyKC0tY29sb3ItZ3JlZW4pXCIsXG4gICAgXCJ2YXIoLS1jb2xvci15ZWxsb3cpXCIsXG4gICAgXCJ2YXIoLS1jb2xvci1vcmFuZ2UpXCIsXG4gICAgXCJ2YXIoLS1jb2xvci1yZWQpXCIsXG4gICAgXCJ2YXIoLS1jb2xvci1wdXJwbGUpXCIsXG4gICAgXCJ2YXIoLS1jb2xvci1waW5rKVwiLFxuICAgIFwidmFyKC0tY29sb3ItY3lhbilcIixcbiAgXSxcbn0gYXMgY29uc3Q7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEludGVyYWN0aW9uIFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKiBEYXRhIHBhc3NlZCB0byBjbGljayBoYW5kbGVyICovXG5leHBvcnQgaW50ZXJmYWNlIFBvaW50Q2xpY2tFdmVudCB7XG4gIHJlYWRvbmx5IHBvaW50OiBTY2F0dGVyUG9pbnQ7XG4gIHJlYWRvbmx5IG9yaWdpbmFsRXZlbnQ6IE1vdXNlRXZlbnQ7XG59XG5cbi8qKiBEYXRhIHBhc3NlZCB0byBob3ZlciBoYW5kbGVyICovXG5leHBvcnQgaW50ZXJmYWNlIFBvaW50SG92ZXJFdmVudCB7XG4gIHJlYWRvbmx5IHBvaW50OiBTY2F0dGVyUG9pbnQ7XG4gIHJlYWRvbmx5IHRhcmdldEVsOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQ7XG4gIHJlYWRvbmx5IG9yaWdpbmFsRXZlbnQ6IE1vdXNlRXZlbnQ7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFZpZXcgU3RhdGUgVHlwZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIHNjYXR0ZXIgcGxvdCB2aWV3ICovXG5leHBvcnQgaW50ZXJmYWNlIFZpZXdTdGF0ZSB7XG4gIHJlYWRvbmx5IGNvbmZpZzogU2NhdHRlckNvbmZpZztcbiAgcmVhZG9ubHkgZGF0YTogRGF0YUV4dHJhY3Rpb25SZXN1bHQgfCBudWxsO1xuICByZWFkb25seSBib3VuZHM6IFBsb3RCb3VuZHMgfCBudWxsO1xuICByZWFkb25seSB2aWV3cG9ydDogVmlld3BvcnREaW1lbnNpb25zO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9WSUVXUE9SVDogVmlld3BvcnREaW1lbnNpb25zID0ge1xuICB3aWR0aDogODAwLFxuICBoZWlnaHQ6IDYwMCxcbiAgbWFyZ2luOiB7XG4gICAgdG9wOiAyMCxcbiAgICByaWdodDogMjAsXG4gICAgYm90dG9tOiA0MCxcbiAgICBsZWZ0OiA1MCxcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFV0aWxpdHkgVHlwZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqIEdlbmVyaWMgcmVzdWx0IHR5cGUgZm9yIG9wZXJhdGlvbnMgdGhhdCBjYW4gZmFpbCAqL1xuZXhwb3J0IHR5cGUgUmVzdWx0PFQsIEUgPSBzdHJpbmc+ID1cbiAgfCB7IHJlYWRvbmx5IG9rOiB0cnVlOyByZWFkb25seSB2YWx1ZTogVCB9XG4gIHwgeyByZWFkb25seSBvazogZmFsc2U7IHJlYWRvbmx5IGVycm9yOiBFIH07XG5cbi8qKiBIZWxwZXIgdG8gY3JlYXRlIHN1Y2Nlc3MgcmVzdWx0ICovXG5leHBvcnQgY29uc3Qgb2sgPSA8VD4odmFsdWU6IFQpOiBSZXN1bHQ8VCwgbmV2ZXI+ID0+ICh7XG4gIG9rOiB0cnVlLFxuICB2YWx1ZSxcbn0pO1xuXG4vKiogSGVscGVyIHRvIGNyZWF0ZSBlcnJvciByZXN1bHQgKi9cbmV4cG9ydCBjb25zdCBlcnIgPSA8RT4oZXJyb3I6IEUpOiBSZXN1bHQ8bmV2ZXIsIEU+ID0+ICh7XG4gIG9rOiBmYWxzZSxcbiAgZXJyb3IsXG59KTtcbiIsICIvKipcbiAqIFB1cmUgZnVuY3Rpb25zIGZvciBleHRyYWN0aW5nIGFuZCB0cmFuc2Zvcm1pbmcgZGF0YSBmcm9tIEJhc2VzIGVudHJpZXNcbiAqIGludG8gc2NhdHRlciBwbG90IHBvaW50cy5cbiAqXG4gKiBBbGwgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGFyZSBwdXJlIC0gbm8gc2lkZSBlZmZlY3RzLCBubyBtdXRhdGlvbnMuXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBCYXNlc0VudHJ5IH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgdHlwZSB7XG4gIFNjYXR0ZXJQb2ludCxcbiAgU2NhdHRlckNvbmZpZyxcbiAgTnVtZXJpY0V4dHJhY3Rpb25SZXN1bHQsXG4gIENhdGVnb3J5RXh0cmFjdGlvblJlc3VsdCxcbiAgRGF0YUV4dHJhY3Rpb25SZXN1bHQsXG4gIFNraXBwZWRFbnRyeSxcbiAgQXhpc0JvdW5kcyxcbiAgUGxvdEJvdW5kcyxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVmFsdWUgSGVscGVyc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGZyb20gdGhlIEJhc2VzIEFQSSBpcyBlbXB0eS5cbiAqIEhhbmRsZXMgdGhlIFZhbHVlIHdyYXBwZXIgd2hpY2ggbWF5IGhhdmUgYW4gaXNFbXB0eSgpIG1ldGhvZC5cbiAqL1xuY29uc3QgaXNWYWx1ZUVtcHR5ID0gKHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBcImlzRW1wdHlcIiBpbiB2YWx1ZSkge1xuICAgIGNvbnN0IHYgPSB2YWx1ZSBhcyB7IGlzRW1wdHk6ICgpID0+IGJvb2xlYW4gfTtcbiAgICByZXR1cm4gdi5pc0VtcHR5KCk7XG4gIH1cbiAgcmV0dXJuICF2YWx1ZTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFZhbHVlIEV4dHJhY3Rpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBleHRyYWN0IGEgbnVtZXJpYyB2YWx1ZSBmcm9tIGEgQmFzZXMgZW50cnkgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gKiBIYW5kbGVzIHRoZSBWYWx1ZSB3cmFwcGVyIHJldHVybmVkIGJ5IGVudHJ5LmdldFZhbHVlKCkuXG4gKi9cbmV4cG9ydCBjb25zdCBleHRyYWN0TnVtZXJpY1ZhbHVlID0gKFxuICBlbnRyeTogQmFzZXNFbnRyeSxcbiAgcHJvcGVydHlJZDogc3RyaW5nXG4pOiBOdW1lcmljRXh0cmFjdGlvblJlc3VsdCA9PiB7XG4gIHRyeSB7XG4gICAgLy8gQ2FzdCB0byBleHBlY3RlZCB0ZW1wbGF0ZSBsaXRlcmFsIHR5cGUgLSB0aGUgQVBJIGFjY2VwdHMgdGhlc2UgcHJlZml4ZXNcbiAgICBjb25zdCB2YWx1ZSA9IGVudHJ5LmdldFZhbHVlKHByb3BlcnR5SWQgYXMgYG5vdGUuJHtzdHJpbmd9YCk7XG5cbiAgICAvLyBDaGVjayBpZiB2YWx1ZSBpcyBlbXB0eSB1c2luZyB0aGUgVmFsdWUgd3JhcHBlcidzIGlzRW1wdHkgbWV0aG9kIGlmIGF2YWlsYWJsZVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzVmFsdWVFbXB0eSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCByZWFzb246IGBQcm9wZXJ0eSBcIiR7cHJvcGVydHlJZH1cIiBpcyBlbXB0eWAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbnVtZXJpY1ZhbHVlID0gTnVtYmVyKHN0cmluZ1ZhbHVlKTtcblxuICAgIGlmIChOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIHJlYXNvbjogYFByb3BlcnR5IFwiJHtwcm9wZXJ0eUlkfVwiIHZhbHVlIFwiJHtzdHJpbmdWYWx1ZX1cIiBpcyBub3QgbnVtZXJpY2AsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG51bWVyaWNWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICByZWFzb246IGBQcm9wZXJ0eSBcIiR7cHJvcGVydHlJZH1cIiB2YWx1ZSBpcyBub3QgZmluaXRlYCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IG51bWVyaWNWYWx1ZSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgcmVhc29uOiBgRmFpbGVkIHRvIHJlYWQgcHJvcGVydHkgXCIke3Byb3BlcnR5SWR9XCI6ICR7U3RyaW5nKGUpfWAsXG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBleHRyYWN0IGEgY2F0ZWdvcmljYWwgKHN0cmluZykgdmFsdWUgZnJvbSBhIEJhc2VzIGVudHJ5LlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSwgb3IgbnVsbCBpZiBlbXB0eS5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RDYXRlZ29yeVZhbHVlID0gKFxuICBlbnRyeTogQmFzZXNFbnRyeSxcbiAgcHJvcGVydHlJZDogc3RyaW5nIHwgbnVsbFxuKTogQ2F0ZWdvcnlFeHRyYWN0aW9uUmVzdWx0ID0+IHtcbiAgaWYgKHByb3BlcnR5SWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSB9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBDYXN0IHRvIGV4cGVjdGVkIHRlbXBsYXRlIGxpdGVyYWwgdHlwZVxuICAgIGNvbnN0IHZhbHVlID0gZW50cnkuZ2V0VmFsdWUocHJvcGVydHlJZCBhcyBgbm90ZS4ke3N0cmluZ31gKTtcblxuICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGVtcHR5IHVzaW5nIHRoZSBWYWx1ZSB3cmFwcGVyJ3MgaXNFbXB0eSBtZXRob2QgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXNWYWx1ZUVtcHR5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogdmFsdWUudG9TdHJpbmcoKSB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSB9O1xuICB9XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQb2ludCBFeHRyYWN0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gY3JlYXRlIGEgU2NhdHRlclBvaW50IGZyb20gYSBzaW5nbGUgQmFzZXMgZW50cnkuXG4gKiBSZXR1cm5zIGVpdGhlciB0aGUgcG9pbnQgb3IgYSBTa2lwcGVkRW50cnkgd2l0aCByZWFzb24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnRyeVRvUG9pbnQgPSAoXG4gIGVudHJ5OiBCYXNlc0VudHJ5LFxuICBjb25maWc6IFNjYXR0ZXJDb25maWdcbik6IFNjYXR0ZXJQb2ludCB8IFNraXBwZWRFbnRyeSA9PiB7XG4gIGNvbnN0IHsgeEF4aXMsIHlBeGlzLCBjb2xvckJ5IH0gPSBjb25maWc7XG5cbiAgLy8gVmFsaWRhdGUgY29uZmlnXG4gIGlmICh4QXhpcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7IGZpbGU6IGVudHJ5LmZpbGUsIHJlYXNvbjogXCJYIGF4aXMgcHJvcGVydHkgbm90IGNvbmZpZ3VyZWRcIiB9O1xuICB9XG4gIGlmICh5QXhpcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7IGZpbGU6IGVudHJ5LmZpbGUsIHJlYXNvbjogXCJZIGF4aXMgcHJvcGVydHkgbm90IGNvbmZpZ3VyZWRcIiB9O1xuICB9XG5cbiAgLy8gRXh0cmFjdCBYIHZhbHVlXG4gIGNvbnN0IHhSZXN1bHQgPSBleHRyYWN0TnVtZXJpY1ZhbHVlKGVudHJ5LCB4QXhpcyk7XG4gIGlmICgheFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgZmlsZTogZW50cnkuZmlsZSwgcmVhc29uOiB4UmVzdWx0LnJlYXNvbiB9O1xuICB9XG5cbiAgLy8gRXh0cmFjdCBZIHZhbHVlXG4gIGNvbnN0IHlSZXN1bHQgPSBleHRyYWN0TnVtZXJpY1ZhbHVlKGVudHJ5LCB5QXhpcyk7XG4gIGlmICgheVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgZmlsZTogZW50cnkuZmlsZSwgcmVhc29uOiB5UmVzdWx0LnJlYXNvbiB9O1xuICB9XG5cbiAgLy8gRXh0cmFjdCBjYXRlZ29yeSAob3B0aW9uYWwpXG4gIGNvbnN0IGNhdGVnb3J5UmVzdWx0ID0gZXh0cmFjdENhdGVnb3J5VmFsdWUoZW50cnksIGNvbG9yQnkpO1xuICBjb25zdCBjYXRlZ29yeSA9IGNhdGVnb3J5UmVzdWx0LnN1Y2Nlc3MgPyBjYXRlZ29yeVJlc3VsdC52YWx1ZSA6IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4UmVzdWx0LnZhbHVlLFxuICAgIHk6IHlSZXN1bHQudmFsdWUsXG4gICAgY2F0ZWdvcnksXG4gICAgbGFiZWw6IGVudHJ5LmZpbGUuYmFzZW5hbWUsXG4gICAgZmlsZTogZW50cnkuZmlsZSxcbiAgICBlbnRyeSxcbiAgfTtcbn07XG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBleHRyYWN0aW9uIHJlc3VsdCBpcyBhIHZhbGlkIHBvaW50XG4gKi9cbmV4cG9ydCBjb25zdCBpc1NjYXR0ZXJQb2ludCA9IChcbiAgcmVzdWx0OiBTY2F0dGVyUG9pbnQgfCBTa2lwcGVkRW50cnlcbik6IHJlc3VsdCBpcyBTY2F0dGVyUG9pbnQgPT4ge1xuICByZXR1cm4gXCJ4XCIgaW4gcmVzdWx0ICYmIFwieVwiIGluIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBleHRyYWN0aW9uIHJlc3VsdCBpcyBhIHNraXBwZWQgZW50cnlcbiAqL1xuZXhwb3J0IGNvbnN0IGlzU2tpcHBlZEVudHJ5ID0gKFxuICByZXN1bHQ6IFNjYXR0ZXJQb2ludCB8IFNraXBwZWRFbnRyeVxuKTogcmVzdWx0IGlzIFNraXBwZWRFbnRyeSA9PiB7XG4gIHJldHVybiBcInJlYXNvblwiIGluIHJlc3VsdDtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEJhdGNoIFByb2Nlc3Npbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBFeHRyYWN0cyB1bmlxdWUgY2F0ZWdvcmllcyBmcm9tIGEgbGlzdCBvZiBwb2ludHMuXG4gKiBQcmVzZXJ2ZXMgaW5zZXJ0aW9uIG9yZGVyLCBmaWx0ZXJzIG91dCBudWxscy5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RDYXRlZ29yaWVzID0gKHBvaW50czogcmVhZG9ubHkgU2NhdHRlclBvaW50W10pOiBzdHJpbmdbXSA9PiB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3QgY2F0ZWdvcmllczogc3RyaW5nW10gPSBbXTtcblxuICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgIGlmIChwb2ludC5jYXRlZ29yeSAhPT0gbnVsbCAmJiAhc2Vlbi5oYXMocG9pbnQuY2F0ZWdvcnkpKSB7XG4gICAgICBzZWVuLmFkZChwb2ludC5jYXRlZ29yeSk7XG4gICAgICBjYXRlZ29yaWVzLnB1c2gocG9pbnQuY2F0ZWdvcnkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYXRlZ29yaWVzO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgYWxsIGVudHJpZXMgZnJvbSBncm91cGVkIGRhdGEgaW50byBzY2F0dGVyIHBvaW50cy5cbiAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIGRhdGEgZXh0cmFjdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3REYXRhRnJvbUVudHJpZXMgPSAoXG4gIGVudHJpZXM6IHJlYWRvbmx5IEJhc2VzRW50cnlbXSxcbiAgY29uZmlnOiBTY2F0dGVyQ29uZmlnXG4pOiBEYXRhRXh0cmFjdGlvblJlc3VsdCA9PiB7XG4gIGNvbnN0IHBvaW50czogU2NhdHRlclBvaW50W10gPSBbXTtcbiAgY29uc3Qgc2tpcHBlZDogU2tpcHBlZEVudHJ5W10gPSBbXTtcblxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBlbnRyeVRvUG9pbnQoZW50cnksIGNvbmZpZyk7XG5cbiAgICBpZiAoaXNTY2F0dGVyUG9pbnQocmVzdWx0KSkge1xuICAgICAgcG9pbnRzLnB1c2gocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2tpcHBlZC5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2F0ZWdvcmllcyA9IGV4dHJhY3RDYXRlZ29yaWVzKHBvaW50cyk7XG5cbiAgcmV0dXJuIHsgcG9pbnRzLCBza2lwcGVkLCBjYXRlZ29yaWVzIH07XG59O1xuXG4vKipcbiAqIEZsYXR0ZW5zIGdyb3VwZWQgZGF0YSBmcm9tIEJhc2VzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgZW50cmllcy5cbiAqIEJhc2VzIHByb3ZpZGVzIGRhdGEgaW4gZ3JvdXBzLCBidXQgZm9yIHNjYXR0ZXIgcGxvdCB3ZSB0cmVhdCB0aGVtIHVuaWZvcm1seS5cbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXR0ZW5Hcm91cGVkRGF0YSA9IChcbiAgZ3JvdXBlZERhdGE6IHJlYWRvbmx5IHsgZW50cmllczogcmVhZG9ubHkgQmFzZXNFbnRyeVtdIH1bXVxuKTogQmFzZXNFbnRyeVtdID0+IHtcbiAgcmV0dXJuIGdyb3VwZWREYXRhLmZsYXRNYXAoKGdyb3VwKSA9PiBbLi4uZ3JvdXAuZW50cmllc10pO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQm91bmRzIENhbGN1bGF0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBheGlzIGJvdW5kcyBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMgd2l0aCBvcHRpb25hbCBwYWRkaW5nLlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBsaXN0IGlzIGVtcHR5LlxuICovXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlQXhpc0JvdW5kcyA9IChcbiAgdmFsdWVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgcGFkZGluZ1BlcmNlbnQ6IG51bWJlciA9IDAuMDVcbik6IEF4aXNCb3VuZHMgfCBudWxsID0+IHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKC4uLnZhbHVlcyk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLnZhbHVlcyk7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuXG4gIC8vIEhhbmRsZSBjYXNlIHdoZXJlIGFsbCB2YWx1ZXMgYXJlIHRoZSBzYW1lXG4gIGNvbnN0IHBhZGRpbmcgPSByYW5nZSA9PT0gMCA/IE1hdGguYWJzKG1pbikgKiBwYWRkaW5nUGVyY2VudCB8fCAxIDogcmFuZ2UgKiBwYWRkaW5nUGVyY2VudDtcblxuICByZXR1cm4ge1xuICAgIG1pbjogbWluIC0gcGFkZGluZyxcbiAgICBtYXg6IG1heCArIHBhZGRpbmcsXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYm91bmRzIGZvciBib3RoIGF4ZXMgZnJvbSBzY2F0dGVyIHBvaW50cy5cbiAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzLlxuICovXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlUGxvdEJvdW5kcyA9IChcbiAgcG9pbnRzOiByZWFkb25seSBTY2F0dGVyUG9pbnRbXSxcbiAgcGFkZGluZ1BlcmNlbnQ6IG51bWJlciA9IDAuMDVcbik6IFBsb3RCb3VuZHMgfCBudWxsID0+IHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHhWYWx1ZXMgPSBwb2ludHMubWFwKChwKSA9PiBwLngpO1xuICBjb25zdCB5VmFsdWVzID0gcG9pbnRzLm1hcCgocCkgPT4gcC55KTtcblxuICBjb25zdCB4Qm91bmRzID0gY2FsY3VsYXRlQXhpc0JvdW5kcyh4VmFsdWVzLCBwYWRkaW5nUGVyY2VudCk7XG4gIGNvbnN0IHlCb3VuZHMgPSBjYWxjdWxhdGVBeGlzQm91bmRzKHlWYWx1ZXMsIHBhZGRpbmdQZXJjZW50KTtcblxuICBpZiAoeEJvdW5kcyA9PT0gbnVsbCB8fCB5Qm91bmRzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4geyB4OiB4Qm91bmRzLCB5OiB5Qm91bmRzIH07XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDb29yZGluYXRlIFRyYW5zZm9ybWF0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxpbmVhciBzY2FsZSBmdW5jdGlvbiB0aGF0IG1hcHMgZnJvbSBkYXRhIHNwYWNlIHRvIHNjcmVlbiBzcGFjZS5cbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgYSBkYXRhIHZhbHVlIHRvIGEgc2NyZWVuIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVMaW5lYXJTY2FsZSA9IChcbiAgZG9tYWluTWluOiBudW1iZXIsXG4gIGRvbWFpbk1heDogbnVtYmVyLFxuICByYW5nZU1pbjogbnVtYmVyLFxuICByYW5nZU1heDogbnVtYmVyXG4pOiAoKHZhbHVlOiBudW1iZXIpID0+IG51bWJlcikgPT4ge1xuICBjb25zdCBkb21haW5TcGFuID0gZG9tYWluTWF4IC0gZG9tYWluTWluO1xuICBjb25zdCByYW5nZVNwYW4gPSByYW5nZU1heCAtIHJhbmdlTWluO1xuXG4gIC8vIEhhbmRsZSBkZWdlbmVyYXRlIGNhc2Ugd2hlcmUgZG9tYWluIGhhcyBubyBzcGFuXG4gIGlmIChkb21haW5TcGFuID09PSAwKSB7XG4gICAgcmV0dXJuICgpID0+IChyYW5nZU1pbiArIHJhbmdlTWF4KSAvIDI7XG4gIH1cblxuICByZXR1cm4gKHZhbHVlOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSAodmFsdWUgLSBkb21haW5NaW4pIC8gZG9tYWluU3BhbjtcbiAgICByZXR1cm4gcmFuZ2VNaW4gKyBub3JtYWxpemVkICogcmFuZ2VTcGFuO1xuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGludmVyc2UgbGluZWFyIHNjYWxlIChzY3JlZW4gc3BhY2UgdG8gZGF0YSBzcGFjZSkuXG4gKiBVc2VmdWwgZm9yIHpvb20vcGFuIGNhbGN1bGF0aW9ucy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUludmVyc2VMaW5lYXJTY2FsZSA9IChcbiAgZG9tYWluTWluOiBudW1iZXIsXG4gIGRvbWFpbk1heDogbnVtYmVyLFxuICByYW5nZU1pbjogbnVtYmVyLFxuICByYW5nZU1heDogbnVtYmVyXG4pOiAoKHNjcmVlblZhbHVlOiBudW1iZXIpID0+IG51bWJlcikgPT4ge1xuICBjb25zdCBkb21haW5TcGFuID0gZG9tYWluTWF4IC0gZG9tYWluTWluO1xuICBjb25zdCByYW5nZVNwYW4gPSByYW5nZU1heCAtIHJhbmdlTWluO1xuXG4gIGlmIChyYW5nZVNwYW4gPT09IDApIHtcbiAgICByZXR1cm4gKCkgPT4gKGRvbWFpbk1pbiArIGRvbWFpbk1heCkgLyAyO1xuICB9XG5cbiAgcmV0dXJuIChzY3JlZW5WYWx1ZTogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gKHNjcmVlblZhbHVlIC0gcmFuZ2VNaW4pIC8gcmFuZ2VTcGFuO1xuICAgIHJldHVybiBkb21haW5NaW4gKyBub3JtYWxpemVkICogZG9tYWluU3BhbjtcbiAgfTtcbn07XG4iLCAiLyoqXG4gKiBTVkcgcmVuZGVyaW5nIGZ1bmN0aW9ucyBmb3IgdGhlIHNjYXR0ZXIgcGxvdC5cbiAqXG4gKiBVc2VzIHZhbmlsbGEgRE9NIG1hbmlwdWxhdGlvbiBmb3IgU1ZHIGNyZWF0aW9uLlxuICogQWxsIHJlbmRlcmluZyBmdW5jdGlvbnMgYXJlIHB1cmUgLSB0aGV5IGNyZWF0ZSBuZXcgZWxlbWVudHMgcmF0aGVyIHRoYW4gbXV0YXRpbmcuXG4gKi9cblxuaW1wb3J0IHR5cGUge1xuICBTY2F0dGVyUG9pbnQsXG4gIFJlbmRlcmVkUG9pbnQsXG4gIFBsb3RCb3VuZHMsXG4gIFZpZXdwb3J0RGltZW5zaW9ucyxcbiAgSW5uZXJEaW1lbnNpb25zLFxuICBDb2xvclBhbGV0dGUsXG4gIEF4aXNCb3VuZHMsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBTEVUVEUgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlTGluZWFyU2NhbGUgfSBmcm9tIFwiLi9kYXRhXCI7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNWRyBOYW1lc3BhY2Vcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuXG4vKiogSGVscGVyIHRvIGNyZWF0ZSBhbiBTVkcgZWxlbWVudCB3aXRoIGF0dHJpYnV0ZXMgKi9cbmNvbnN0IGNyZWF0ZVN2Z0VsZW1lbnQgPSA8SyBleHRlbmRzIGtleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwPihcbiAgdGFnOiBLLFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXI+ID0ge31cbik6IFNWR0VsZW1lbnRUYWdOYW1lTWFwW0tdID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHRhZyk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERpbWVuc2lvbiBDYWxjdWxhdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqIENhbGN1bGF0ZXMgaW5uZXIgZGltZW5zaW9ucyAodmlld3BvcnQgbWludXMgbWFyZ2lucykgKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVJbm5lckRpbWVuc2lvbnMgPSAoXG4gIHZpZXdwb3J0OiBWaWV3cG9ydERpbWVuc2lvbnNcbik6IElubmVyRGltZW5zaW9ucyA9PiAoe1xuICB3aWR0aDogdmlld3BvcnQud2lkdGggLSB2aWV3cG9ydC5tYXJnaW4ubGVmdCAtIHZpZXdwb3J0Lm1hcmdpbi5yaWdodCxcbiAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQgLSB2aWV3cG9ydC5tYXJnaW4udG9wIC0gdmlld3BvcnQubWFyZ2luLmJvdHRvbSxcbn0pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDb2xvciBBc3NpZ25tZW50XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIGNhdGVnb3J5IG5hbWVzIHRvIGNvbG9ycyAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNhdGVnb3J5Q29sb3JNYXAgPSAoXG4gIGNhdGVnb3JpZXM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICBwYWxldHRlOiBDb2xvclBhbGV0dGUgPSBERUZBVUxUX1BBTEVUVEVcbik6IE1hcDxzdHJpbmcsIHN0cmluZz4gPT4ge1xuICBjb25zdCBjb2xvck1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cbiAgY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjb2xvckluZGV4ID0gaW5kZXggJSBwYWxldHRlLmNvbG9ycy5sZW5ndGg7XG4gICAgY29sb3JNYXAuc2V0KGNhdGVnb3J5LCBwYWxldHRlLmNvbG9yc1tjb2xvckluZGV4XSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb2xvck1hcDtcbn07XG5cbi8qKiBHZXRzIHRoZSBjb2xvciBmb3IgYSBwb2ludCBiYXNlZCBvbiBpdHMgY2F0ZWdvcnkgKi9cbmV4cG9ydCBjb25zdCBnZXRQb2ludENvbG9yID0gKFxuICBwb2ludDogU2NhdHRlclBvaW50LFxuICBjb2xvck1hcDogTWFwPHN0cmluZywgc3RyaW5nPixcbiAgZmFsbGJhY2s6IHN0cmluZyA9IERFRkFVTFRfUEFMRVRURS5mYWxsYmFja1xuKTogc3RyaW5nID0+IHtcbiAgaWYgKHBvaW50LmNhdGVnb3J5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIHJldHVybiBjb2xvck1hcC5nZXQocG9pbnQuY2F0ZWdvcnkpID8/IGZhbGxiYWNrO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUG9pbnQgVHJhbnNmb3JtYXRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqIFRyYW5zZm9ybXMgZGF0YSBwb2ludHMgdG8gc2NyZWVuIGNvb3JkaW5hdGVzICovXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtUG9pbnRzVG9TY3JlZW4gPSAoXG4gIHBvaW50czogcmVhZG9ubHkgU2NhdHRlclBvaW50W10sXG4gIGJvdW5kczogUGxvdEJvdW5kcyxcbiAgaW5uZXI6IElubmVyRGltZW5zaW9ucyxcbiAgY29sb3JNYXA6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gIHBhbGV0dGU6IENvbG9yUGFsZXR0ZSA9IERFRkFVTFRfUEFMRVRURVxuKTogUmVuZGVyZWRQb2ludFtdID0+IHtcbiAgY29uc3Qgc2NhbGVYID0gY3JlYXRlTGluZWFyU2NhbGUoYm91bmRzLngubWluLCBib3VuZHMueC5tYXgsIDAsIGlubmVyLndpZHRoKTtcbiAgLy8gWSBheGlzIGlzIGludmVydGVkIChzY3JlZW4gWSBpbmNyZWFzZXMgZG93bndhcmQpXG4gIGNvbnN0IHNjYWxlWSA9IGNyZWF0ZUxpbmVhclNjYWxlKGJvdW5kcy55Lm1pbiwgYm91bmRzLnkubWF4LCBpbm5lci5oZWlnaHQsIDApO1xuXG4gIHJldHVybiBwb2ludHMubWFwKChwb2ludCkgPT4gKHtcbiAgICAuLi5wb2ludCxcbiAgICBzY3JlZW5YOiBzY2FsZVgocG9pbnQueCksXG4gICAgc2NyZWVuWTogc2NhbGVZKHBvaW50LnkpLFxuICAgIGNvbG9yOiBnZXRQb2ludENvbG9yKHBvaW50LCBjb2xvck1hcCwgcGFsZXR0ZS5mYWxsYmFjayksXG4gIH0pKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEF4aXMgUmVuZGVyaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKiBDb25maWd1cmF0aW9uIGZvciBheGlzIHRpY2sgZ2VuZXJhdGlvbiAqL1xuaW50ZXJmYWNlIFRpY2tDb25maWcge1xuICByZWFkb25seSBjb3VudDogbnVtYmVyO1xuICByZWFkb25seSBmb3JtYXQ6ICh2YWx1ZTogbnVtYmVyKSA9PiBzdHJpbmc7XG59XG5cbmNvbnN0IERFRkFVTFRfVElDS19DT05GSUc6IFRpY2tDb25maWcgPSB7XG4gIGNvdW50OiA1LFxuICBmb3JtYXQ6ICh2KSA9PiB2LnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwgeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIgfSksXG59O1xuXG4vKiogR2VuZXJhdGVzIG5pY2UgdGljayB2YWx1ZXMgZm9yIGFuIGF4aXMgKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVRpY2tzID0gKFxuICBib3VuZHM6IEF4aXNCb3VuZHMsXG4gIGNvdW50OiBudW1iZXIgPSBERUZBVUxUX1RJQ0tfQ09ORklHLmNvdW50XG4pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJhbmdlID0gYm91bmRzLm1heCAtIGJvdW5kcy5taW47XG4gIGNvbnN0IHN0ZXAgPSByYW5nZSAvIChjb3VudCAtIDEpO1xuXG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb3VudCB9LCAoXywgaSkgPT4gYm91bmRzLm1pbiArIGkgKiBzdGVwKTtcbn07XG5cbi8qKiBDcmVhdGVzIGFuIFggYXhpcyBTVkcgZ3JvdXAgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVYQXhpcyA9IChcbiAgYm91bmRzOiBBeGlzQm91bmRzLFxuICBpbm5lcjogSW5uZXJEaW1lbnNpb25zLFxuICBsYWJlbDogc3RyaW5nLFxuICB0aWNrQ29uZmlnOiBUaWNrQ29uZmlnID0gREVGQVVMVF9USUNLX0NPTkZJR1xuKTogU1ZHR0VsZW1lbnQgPT4ge1xuICBjb25zdCBncm91cCA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJnXCIsIHsgY2xhc3M6IFwic2NhdHRlci1heGlzIHNjYXR0ZXItYXhpcy14XCIgfSk7XG4gIGNvbnN0IHNjYWxlID0gY3JlYXRlTGluZWFyU2NhbGUoYm91bmRzLm1pbiwgYm91bmRzLm1heCwgMCwgaW5uZXIud2lkdGgpO1xuICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoYm91bmRzLCB0aWNrQ29uZmlnLmNvdW50KTtcblxuICAvLyBBeGlzIGxpbmVcbiAgY29uc3QgYXhpc0xpbmUgPSBjcmVhdGVTdmdFbGVtZW50KFwibGluZVwiLCB7XG4gICAgeDE6IDAsXG4gICAgeTE6IGlubmVyLmhlaWdodCxcbiAgICB4MjogaW5uZXIud2lkdGgsXG4gICAgeTI6IGlubmVyLmhlaWdodCxcbiAgICBjbGFzczogXCJzY2F0dGVyLWF4aXMtbGluZVwiLFxuICAgIHN0cm9rZTogXCJ2YXIoLS10ZXh0LW11dGVkKVwiLFxuICAgIFwic3Ryb2tlLXdpZHRoXCI6IDEsXG4gIH0pO1xuICBncm91cC5hcHBlbmRDaGlsZChheGlzTGluZSk7XG5cbiAgLy8gVGlja3MgYW5kIGxhYmVsc1xuICBmb3IgKGNvbnN0IHRpY2sgb2YgdGlja3MpIHtcbiAgICBjb25zdCB4ID0gc2NhbGUodGljayk7XG5cbiAgICBjb25zdCB0aWNrTGluZSA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJsaW5lXCIsIHtcbiAgICAgIHgxOiB4LFxuICAgICAgeTE6IGlubmVyLmhlaWdodCxcbiAgICAgIHgyOiB4LFxuICAgICAgeTI6IGlubmVyLmhlaWdodCArIDYsXG4gICAgICBjbGFzczogXCJzY2F0dGVyLXRpY2tcIixcbiAgICAgIHN0cm9rZTogXCJ2YXIoLS10ZXh0LW11dGVkKVwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcbiAgICB9KTtcbiAgICBncm91cC5hcHBlbmRDaGlsZCh0aWNrTGluZSk7XG5cbiAgICBjb25zdCB0aWNrTGFiZWwgPSBjcmVhdGVTdmdFbGVtZW50KFwidGV4dFwiLCB7XG4gICAgICB4LFxuICAgICAgeTogaW5uZXIuaGVpZ2h0ICsgMjAsXG4gICAgICBjbGFzczogXCJzY2F0dGVyLXRpY2stbGFiZWxcIixcbiAgICAgIFwidGV4dC1hbmNob3JcIjogXCJtaWRkbGVcIixcbiAgICAgIGZpbGw6IFwidmFyKC0tdGV4dC1tdXRlZClcIixcbiAgICAgIFwiZm9udC1zaXplXCI6IFwiMTFweFwiLFxuICAgIH0pO1xuICAgIHRpY2tMYWJlbC50ZXh0Q29udGVudCA9IHRpY2tDb25maWcuZm9ybWF0KHRpY2spO1xuICAgIGdyb3VwLmFwcGVuZENoaWxkKHRpY2tMYWJlbCk7XG4gIH1cblxuICAvLyBBeGlzIGxhYmVsXG4gIGNvbnN0IGF4aXNMYWJlbCA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJ0ZXh0XCIsIHtcbiAgICB4OiBpbm5lci53aWR0aCAvIDIsXG4gICAgeTogaW5uZXIuaGVpZ2h0ICsgMzUsXG4gICAgY2xhc3M6IFwic2NhdHRlci1heGlzLWxhYmVsXCIsXG4gICAgXCJ0ZXh0LWFuY2hvclwiOiBcIm1pZGRsZVwiLFxuICAgIGZpbGw6IFwidmFyKC0tdGV4dC1ub3JtYWwpXCIsXG4gICAgXCJmb250LXNpemVcIjogXCIxMnB4XCIsXG4gIH0pO1xuICBheGlzTGFiZWwudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgZ3JvdXAuYXBwZW5kQ2hpbGQoYXhpc0xhYmVsKTtcblxuICByZXR1cm4gZ3JvdXA7XG59O1xuXG4vKiogQ3JlYXRlcyBhIFkgYXhpcyBTVkcgZ3JvdXAgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVZQXhpcyA9IChcbiAgYm91bmRzOiBBeGlzQm91bmRzLFxuICBpbm5lcjogSW5uZXJEaW1lbnNpb25zLFxuICBsYWJlbDogc3RyaW5nLFxuICB0aWNrQ29uZmlnOiBUaWNrQ29uZmlnID0gREVGQVVMVF9USUNLX0NPTkZJR1xuKTogU1ZHR0VsZW1lbnQgPT4ge1xuICBjb25zdCBncm91cCA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJnXCIsIHsgY2xhc3M6IFwic2NhdHRlci1heGlzIHNjYXR0ZXItYXhpcy15XCIgfSk7XG4gIGNvbnN0IHNjYWxlID0gY3JlYXRlTGluZWFyU2NhbGUoYm91bmRzLm1pbiwgYm91bmRzLm1heCwgaW5uZXIuaGVpZ2h0LCAwKTtcbiAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGJvdW5kcywgdGlja0NvbmZpZy5jb3VudCk7XG5cbiAgLy8gQXhpcyBsaW5lXG4gIGNvbnN0IGF4aXNMaW5lID0gY3JlYXRlU3ZnRWxlbWVudChcImxpbmVcIiwge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHgyOiAwLFxuICAgIHkyOiBpbm5lci5oZWlnaHQsXG4gICAgY2xhc3M6IFwic2NhdHRlci1heGlzLWxpbmVcIixcbiAgICBzdHJva2U6IFwidmFyKC0tdGV4dC1tdXRlZClcIixcbiAgICBcInN0cm9rZS13aWR0aFwiOiAxLFxuICB9KTtcbiAgZ3JvdXAuYXBwZW5kQ2hpbGQoYXhpc0xpbmUpO1xuXG4gIC8vIFRpY2tzIGFuZCBsYWJlbHNcbiAgZm9yIChjb25zdCB0aWNrIG9mIHRpY2tzKSB7XG4gICAgY29uc3QgeSA9IHNjYWxlKHRpY2spO1xuXG4gICAgY29uc3QgdGlja0xpbmUgPSBjcmVhdGVTdmdFbGVtZW50KFwibGluZVwiLCB7XG4gICAgICB4MTogLTYsXG4gICAgICB5MTogeSxcbiAgICAgIHgyOiAwLFxuICAgICAgeTI6IHksXG4gICAgICBjbGFzczogXCJzY2F0dGVyLXRpY2tcIixcbiAgICAgIHN0cm9rZTogXCJ2YXIoLS10ZXh0LW11dGVkKVwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcbiAgICB9KTtcbiAgICBncm91cC5hcHBlbmRDaGlsZCh0aWNrTGluZSk7XG5cbiAgICBjb25zdCB0aWNrTGFiZWwgPSBjcmVhdGVTdmdFbGVtZW50KFwidGV4dFwiLCB7XG4gICAgICB4OiAtMTAsXG4gICAgICB5OiB5ICsgNCxcbiAgICAgIGNsYXNzOiBcInNjYXR0ZXItdGljay1sYWJlbFwiLFxuICAgICAgXCJ0ZXh0LWFuY2hvclwiOiBcImVuZFwiLFxuICAgICAgZmlsbDogXCJ2YXIoLS10ZXh0LW11dGVkKVwiLFxuICAgICAgXCJmb250LXNpemVcIjogXCIxMXB4XCIsXG4gICAgfSk7XG4gICAgdGlja0xhYmVsLnRleHRDb250ZW50ID0gdGlja0NvbmZpZy5mb3JtYXQodGljayk7XG4gICAgZ3JvdXAuYXBwZW5kQ2hpbGQodGlja0xhYmVsKTtcbiAgfVxuXG4gIC8vIEF4aXMgbGFiZWwgKHJvdGF0ZWQpXG4gIGNvbnN0IGF4aXNMYWJlbCA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJ0ZXh0XCIsIHtcbiAgICB4OiAtaW5uZXIuaGVpZ2h0IC8gMixcbiAgICB5OiAtMzUsXG4gICAgY2xhc3M6IFwic2NhdHRlci1heGlzLWxhYmVsXCIsXG4gICAgXCJ0ZXh0LWFuY2hvclwiOiBcIm1pZGRsZVwiLFxuICAgIGZpbGw6IFwidmFyKC0tdGV4dC1ub3JtYWwpXCIsXG4gICAgXCJmb250LXNpemVcIjogXCIxMnB4XCIsXG4gICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgtOTApXCIsXG4gIH0pO1xuICBheGlzTGFiZWwudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgZ3JvdXAuYXBwZW5kQ2hpbGQoYXhpc0xhYmVsKTtcblxuICByZXR1cm4gZ3JvdXA7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQb2ludCBSZW5kZXJpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqIENvbmZpZ3VyYXRpb24gZm9yIHBvaW50IHJlbmRlcmluZyAqL1xuZXhwb3J0IGludGVyZmFjZSBQb2ludFJlbmRlckNvbmZpZyB7XG4gIHJlYWRvbmx5IHJhZGl1czogbnVtYmVyO1xuICByZWFkb25seSBvcGFjaXR5OiBudW1iZXI7XG4gIHJlYWRvbmx5IGhvdmVyUmFkaXVzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPSU5UX0NPTkZJRzogUG9pbnRSZW5kZXJDb25maWcgPSB7XG4gIHJhZGl1czogOCxcbiAgb3BhY2l0eTogMC43LFxuICBob3ZlclJhZGl1czogMTIsXG59O1xuXG4vKiogQ3JlYXRlcyBhbiBTVkcgY2lyY2xlIGZvciBhIHNpbmdsZSBwb2ludCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVBvaW50RWxlbWVudCA9IChcbiAgcG9pbnQ6IFJlbmRlcmVkUG9pbnQsXG4gIGNvbmZpZzogUG9pbnRSZW5kZXJDb25maWcgPSBERUZBVUxUX1BPSU5UX0NPTkZJR1xuKTogU1ZHQ2lyY2xlRWxlbWVudCA9PiB7XG4gIGNvbnN0IGNpcmNsZSA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGN4OiBwb2ludC5zY3JlZW5YLFxuICAgIGN5OiBwb2ludC5zY3JlZW5ZLFxuICAgIHI6IGNvbmZpZy5yYWRpdXMsXG4gICAgZmlsbDogcG9pbnQuY29sb3IsXG4gICAgb3BhY2l0eTogY29uZmlnLm9wYWNpdHksXG4gICAgY2xhc3M6IFwic2NhdHRlci1wb2ludFwiLFxuICAgIFwiZGF0YS1maWxlLXBhdGhcIjogcG9pbnQuZmlsZS5wYXRoLFxuICB9KTtcblxuICAvLyBIb3ZlciBlZmZlY3RzIGFyZSBoYW5kbGVkIGJ5IHRoZSAuc2NhdHRlci1wb2ludCBDU1MgY2xhc3NcblxuICByZXR1cm4gY2lyY2xlO1xufTtcblxuLyoqIENyZWF0ZXMgdGhlIHBvaW50cyBsYXllciBTVkcgZ3JvdXAgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVQb2ludHNMYXllciA9IChcbiAgcG9pbnRzOiByZWFkb25seSBSZW5kZXJlZFBvaW50W10sXG4gIGNvbmZpZzogUG9pbnRSZW5kZXJDb25maWcgPSBERUZBVUxUX1BPSU5UX0NPTkZJR1xuKTogU1ZHR0VsZW1lbnQgPT4ge1xuICBjb25zdCBncm91cCA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJnXCIsIHsgY2xhc3M6IFwic2NhdHRlci1wb2ludHNcIiB9KTtcblxuICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgIGNvbnN0IGNpcmNsZSA9IGNyZWF0ZVBvaW50RWxlbWVudChwb2ludCwgY29uZmlnKTtcbiAgICBncm91cC5hcHBlbmRDaGlsZChjaXJjbGUpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gR3JpZCBMaW5lcyAoT3B0aW9uYWwpXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKiBDcmVhdGVzIGdyaWQgbGluZXMgZm9yIGJldHRlciByZWFkYWJpbGl0eSAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUdyaWRMaW5lcyA9IChcbiAgeEJvdW5kczogQXhpc0JvdW5kcyxcbiAgeUJvdW5kczogQXhpc0JvdW5kcyxcbiAgaW5uZXI6IElubmVyRGltZW5zaW9ucyxcbiAgdGlja0NvdW50OiBudW1iZXIgPSA1XG4pOiBTVkdHRWxlbWVudCA9PiB7XG4gIGNvbnN0IGdyb3VwID0gY3JlYXRlU3ZnRWxlbWVudChcImdcIiwgeyBjbGFzczogXCJzY2F0dGVyLWdyaWRcIiB9KTtcblxuICBjb25zdCB4U2NhbGUgPSBjcmVhdGVMaW5lYXJTY2FsZSh4Qm91bmRzLm1pbiwgeEJvdW5kcy5tYXgsIDAsIGlubmVyLndpZHRoKTtcbiAgY29uc3QgeVNjYWxlID0gY3JlYXRlTGluZWFyU2NhbGUoeUJvdW5kcy5taW4sIHlCb3VuZHMubWF4LCBpbm5lci5oZWlnaHQsIDApO1xuXG4gIGNvbnN0IHhUaWNrcyA9IGdlbmVyYXRlVGlja3MoeEJvdW5kcywgdGlja0NvdW50KTtcbiAgY29uc3QgeVRpY2tzID0gZ2VuZXJhdGVUaWNrcyh5Qm91bmRzLCB0aWNrQ291bnQpO1xuXG4gIC8vIFZlcnRpY2FsIGdyaWQgbGluZXNcbiAgZm9yIChjb25zdCB0aWNrIG9mIHhUaWNrcykge1xuICAgIGNvbnN0IHggPSB4U2NhbGUodGljayk7XG4gICAgY29uc3QgbGluZSA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJsaW5lXCIsIHtcbiAgICAgIHgxOiB4LFxuICAgICAgeTE6IDAsXG4gICAgICB4MjogeCxcbiAgICAgIHkyOiBpbm5lci5oZWlnaHQsXG4gICAgICBjbGFzczogXCJzY2F0dGVyLWdyaWQtbGluZVwiLFxuICAgICAgc3Ryb2tlOiBcInZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKVwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcbiAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBcIjIsMlwiLFxuICAgICAgb3BhY2l0eTogMC41LFxuICAgIH0pO1xuICAgIGdyb3VwLmFwcGVuZENoaWxkKGxpbmUpO1xuICB9XG5cbiAgLy8gSG9yaXpvbnRhbCBncmlkIGxpbmVzXG4gIGZvciAoY29uc3QgdGljayBvZiB5VGlja3MpIHtcbiAgICBjb25zdCB5ID0geVNjYWxlKHRpY2spO1xuICAgIGNvbnN0IGxpbmUgPSBjcmVhdGVTdmdFbGVtZW50KFwibGluZVwiLCB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiB5LFxuICAgICAgeDI6IGlubmVyLndpZHRoLFxuICAgICAgeTI6IHksXG4gICAgICBjbGFzczogXCJzY2F0dGVyLWdyaWQtbGluZVwiLFxuICAgICAgc3Ryb2tlOiBcInZhcigtLWJhY2tncm91bmQtbW9kaWZpZXItYm9yZGVyKVwiLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcbiAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBcIjIsMlwiLFxuICAgICAgb3BhY2l0eTogMC41LFxuICAgIH0pO1xuICAgIGdyb3VwLmFwcGVuZENoaWxkKGxpbmUpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRnVsbCBDaGFydCBBc3NlbWJseVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXJ0UmVuZGVyQ29uZmlnIHtcbiAgcmVhZG9ubHkgdmlld3BvcnQ6IFZpZXdwb3J0RGltZW5zaW9ucztcbiAgcmVhZG9ubHkgcG9pbnRDb25maWc6IFBvaW50UmVuZGVyQ29uZmlnO1xuICByZWFkb25seSBwYWxldHRlOiBDb2xvclBhbGV0dGU7XG4gIHJlYWRvbmx5IHNob3dHcmlkOiBib29sZWFuO1xuICByZWFkb25seSB4TGFiZWw6IHN0cmluZztcbiAgcmVhZG9ubHkgeUxhYmVsOiBzdHJpbmc7XG59XG5cbi8qKiBBc3NlbWJsZXMgdGhlIGNvbXBsZXRlIFNWRyBjaGFydCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNoYXJ0U3ZnID0gKFxuICBwb2ludHM6IHJlYWRvbmx5IFNjYXR0ZXJQb2ludFtdLFxuICBib3VuZHM6IFBsb3RCb3VuZHMsXG4gIGNhdGVnb3JpZXM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICBjb25maWc6IENoYXJ0UmVuZGVyQ29uZmlnXG4pOiBTVkdTVkdFbGVtZW50ID0+IHtcbiAgY29uc3QgeyB2aWV3cG9ydCwgcG9pbnRDb25maWcsIHBhbGV0dGUsIHNob3dHcmlkLCB4TGFiZWwsIHlMYWJlbCB9ID0gY29uZmlnO1xuICBjb25zdCBpbm5lciA9IGNhbGN1bGF0ZUlubmVyRGltZW5zaW9ucyh2aWV3cG9ydCk7XG5cbiAgLy8gQ3JlYXRlIHJvb3QgU1ZHXG4gIGNvbnN0IHN2ZyA9IGNyZWF0ZVN2Z0VsZW1lbnQoXCJzdmdcIiwge1xuICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICB2aWV3Qm94OiBgMCAwICR7dmlld3BvcnQud2lkdGh9ICR7dmlld3BvcnQuaGVpZ2h0fWAsXG4gICAgY2xhc3M6IFwic2NhdHRlci1jaGFydFwiLFxuICB9KTtcblxuICAvLyBDcmVhdGUgbWFpbiBncm91cCB3aXRoIG1hcmdpbiBvZmZzZXRcbiAgY29uc3QgbWFpbkdyb3VwID0gY3JlYXRlU3ZnRWxlbWVudChcImdcIiwge1xuICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke3ZpZXdwb3J0Lm1hcmdpbi5sZWZ0fSwgJHt2aWV3cG9ydC5tYXJnaW4udG9wfSlgLFxuICB9KTtcbiAgc3ZnLmFwcGVuZENoaWxkKG1haW5Hcm91cCk7XG5cbiAgLy8gQWRkIGdyaWQgKGJlaGluZCBldmVyeXRoaW5nKVxuICBpZiAoc2hvd0dyaWQpIHtcbiAgICBtYWluR3JvdXAuYXBwZW5kQ2hpbGQoY3JlYXRlR3JpZExpbmVzKGJvdW5kcy54LCBib3VuZHMueSwgaW5uZXIpKTtcbiAgfVxuXG4gIC8vIENvbG9yIG1hcHBpbmdcbiAgY29uc3QgY29sb3JNYXAgPSBjcmVhdGVDYXRlZ29yeUNvbG9yTWFwKGNhdGVnb3JpZXMsIHBhbGV0dGUpO1xuXG4gIC8vIFRyYW5zZm9ybSBwb2ludHMgdG8gc2NyZWVuIGNvb3JkaW5hdGVzXG4gIGNvbnN0IHJlbmRlcmVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzVG9TY3JlZW4oXG4gICAgcG9pbnRzLFxuICAgIGJvdW5kcyxcbiAgICBpbm5lcixcbiAgICBjb2xvck1hcCxcbiAgICBwYWxldHRlXG4gICk7XG5cbiAgLy8gQWRkIGF4ZXNcbiAgbWFpbkdyb3VwLmFwcGVuZENoaWxkKGNyZWF0ZVhBeGlzKGJvdW5kcy54LCBpbm5lciwgeExhYmVsKSk7XG4gIG1haW5Hcm91cC5hcHBlbmRDaGlsZChjcmVhdGVZQXhpcyhib3VuZHMueSwgaW5uZXIsIHlMYWJlbCkpO1xuXG4gIC8vIEFkZCBwb2ludHMgKG9uIHRvcClcbiAgbWFpbkdyb3VwLmFwcGVuZENoaWxkKGNyZWF0ZVBvaW50c0xheWVyKHJlbmRlcmVkUG9pbnRzLCBwb2ludENvbmZpZykpO1xuXG4gIHJldHVybiBzdmc7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFbXB0eSBTdGF0ZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKiogQ3JlYXRlcyBhbiBlbXB0eSBzdGF0ZSBtZXNzYWdlIGVsZW1lbnQgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVFbXB0eVN0YXRlID0gKG1lc3NhZ2U6IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50ID0+IHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwic2NhdHRlci1lbXB0eS1zdGF0ZVwiO1xuXG4gIGNvbnN0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBpY29uLmNsYXNzTmFtZSA9IFwic2NhdHRlci1lbXB0eS1zdGF0ZS1pY29uXCI7XG4gIGljb24udGV4dENvbnRlbnQgPSBcIlx1RDgzRFx1RENDQVwiO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaWNvbik7XG5cbiAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHRleHQuY2xhc3NOYW1lID0gXCJzY2F0dGVyLWVtcHR5LXN0YXRlLXRleHRcIjtcbiAgdGV4dC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0ZXh0KTtcblxuICByZXR1cm4gY29udGFpbmVyO1xufTtcblxuLyoqIENyZWF0ZXMgYSB3YXJuaW5nIG1lc3NhZ2UgYWJvdXQgc2tpcHBlZCBlbnRyaWVzICovXG5leHBvcnQgY29uc3QgY3JlYXRlU2tpcHBlZFdhcm5pbmcgPSAoY291bnQ6IG51bWJlcik6IEhUTUxEaXZFbGVtZW50ID0+IHtcbiAgY29uc3Qgd2FybmluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHdhcm5pbmcuY2xhc3NOYW1lID0gXCJzY2F0dGVyLXNraXBwZWQtd2FybmluZ1wiO1xuICB3YXJuaW5nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJvdHRvbTogOHB4O1xuICAgIHJpZ2h0OiA4cHg7XG4gICAgZm9udC1zaXplOiAxMXB4O1xuICAgIGNvbG9yOiB2YXIoLS10ZXh0LW11dGVkKTtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrZ3JvdW5kLXNlY29uZGFyeSk7XG4gICAgcGFkZGluZzogNHB4IDhweDtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIGA7XG4gIHdhcm5pbmcudGV4dENvbnRlbnQgPSBgJHtjb3VudH0gbm90ZSR7Y291bnQgPT09IDEgPyBcIlwiIDogXCJzXCJ9IHNraXBwZWQgKG1pc3NpbmcgbnVtZXJpYyB2YWx1ZXMpYDtcblxuICByZXR1cm4gd2FybmluZztcbn07XG4iLCAiLyoqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBmb3IgdGhlIHNjYXR0ZXIgcGxvdC5cbiAqXG4gKiBIYW5kbGVzIGNsaWNrLXRvLW9wZW4gYW5kIGhvdmVyIHRvb2x0aXBzLlxuICovXG5cbmltcG9ydCB0eXBlIHsgQXBwLCBIb3ZlclBhcmVudCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgS2V5bWFwIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgdHlwZSB7IFJlbmRlcmVkUG9pbnQsIFNjYXR0ZXJQb2ludCB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BPSU5UX0NPTkZJRywgdHlwZSBQb2ludFJlbmRlckNvbmZpZyB9IGZyb20gXCIuL3JlbmRlclwiO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQb2ludCBMb29rdXBcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluZGV4IGZyb20gZmlsZSBwYXRocyB0byByZW5kZXJlZCBwb2ludHMgZm9yIHF1aWNrIGxvb2t1cC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVBvaW50SW5kZXggPSAoXG5cdHBvaW50czogcmVhZG9ubHkgUmVuZGVyZWRQb2ludFtdXG4pOiBNYXA8c3RyaW5nLCBSZW5kZXJlZFBvaW50PiA9PiB7XG5cdGNvbnN0IGluZGV4ID0gbmV3IE1hcDxzdHJpbmcsIFJlbmRlcmVkUG9pbnQ+KCk7XG5cdGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG5cdFx0aW5kZXguc2V0KHBvaW50LmZpbGUucGF0aCwgcG9pbnQpO1xuXHR9XG5cdHJldHVybiBpbmRleDtcbn07XG5cbi8qKlxuICogRmluZHMgYSBwb2ludCBmcm9tIGEgY2lyY2xlIGVsZW1lbnQgdXNpbmcgaXRzIGRhdGEgYXR0cmlidXRlLlxuICovXG5leHBvcnQgY29uc3QgZmluZFBvaW50RnJvbUVsZW1lbnQgPSAoXG5cdGVsZW1lbnQ6IFNWR0NpcmNsZUVsZW1lbnQsXG5cdHBvaW50SW5kZXg6IE1hcDxzdHJpbmcsIFJlbmRlcmVkUG9pbnQ+XG4pOiBSZW5kZXJlZFBvaW50IHwgbnVsbCA9PiB7XG5cdGNvbnN0IGZpbGVQYXRoID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWZpbGUtcGF0aFwiKTtcblx0aWYgKGZpbGVQYXRoID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0cmV0dXJuIHBvaW50SW5kZXguZ2V0KGZpbGVQYXRoKSA/PyBudWxsO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ2xpY2sgSGFuZGxlclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIENsaWNrSGFuZGxlckNvbmZpZyB7XG5cdHJlYWRvbmx5IGFwcDogQXBwO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbGljayBoYW5kbGVyIHRoYXQgb3BlbnMgdGhlIG5vdGUgYXNzb2NpYXRlZCB3aXRoIGEgcG9pbnQuXG4gKiBSZXNwZWN0cyBtb2RpZmllciBrZXlzIChDbWQvQ3RybCBmb3IgbmV3IHRhYiwgZXRjLilcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsaWNrSGFuZGxlciA9IChcblx0Y29uZmlnOiBDbGlja0hhbmRsZXJDb25maWdcbik6ICgocG9pbnQ6IFNjYXR0ZXJQb2ludCwgZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQpID0+IHtcblx0Y29uc3QgeyBhcHAgfSA9IGNvbmZpZztcblxuXHRyZXR1cm4gKHBvaW50OiBTY2F0dGVyUG9pbnQsIGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XG5cdFx0Ly8gT25seSBoYW5kbGUgbGVmdCBhbmQgbWlkZGxlIGNsaWNrXG5cdFx0aWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCAmJiBldmVudC5idXR0b24gIT09IDEpIHJldHVybjtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRjb25zdCBwYXRoID0gcG9pbnQuZmlsZS5wYXRoO1xuXHRcdGNvbnN0IG1vZEV2ZW50ID0gS2V5bWFwLmlzTW9kRXZlbnQoZXZlbnQpO1xuXG5cdFx0dm9pZCBhcHAud29ya3NwYWNlLm9wZW5MaW5rVGV4dChwYXRoLCBcIlwiLCBtb2RFdmVudCk7XG5cdH07XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIb3ZlciBIYW5kbGVyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgSG92ZXJIYW5kbGVyQ29uZmlnIHtcblx0cmVhZG9ubHkgYXBwOiBBcHA7XG5cdHJlYWRvbmx5IGhvdmVyUGFyZW50OiBIb3ZlclBhcmVudDtcblx0cmVhZG9ubHkgc291cmNlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhvdmVyIGhhbmRsZXIgdGhhdCB0cmlnZ2VycyBPYnNpZGlhbidzIGhvdmVyIHByZXZpZXcuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVIb3ZlckhhbmRsZXIgPSAoXG5cdGNvbmZpZzogSG92ZXJIYW5kbGVyQ29uZmlnXG4pOiAoKHBvaW50OiBTY2F0dGVyUG9pbnQsIGVsZW1lbnQ6IEVsZW1lbnQsIGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkKSA9PiB7XG5cdGNvbnN0IHsgYXBwLCBob3ZlclBhcmVudCwgc291cmNlIH0gPSBjb25maWc7XG5cblx0cmV0dXJuIChwb2ludDogU2NhdHRlclBvaW50LCBlbGVtZW50OiBFbGVtZW50LCBldmVudDogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuXHRcdGFwcC53b3Jrc3BhY2UudHJpZ2dlcihcImhvdmVyLWxpbmtcIiwge1xuXHRcdFx0ZXZlbnQsXG5cdFx0XHRzb3VyY2UsXG5cdFx0XHRob3ZlclBhcmVudCxcblx0XHRcdHRhcmdldEVsOiBlbGVtZW50LFxuXHRcdFx0bGlua3RleHQ6IHBvaW50LmZpbGUucGF0aCxcblx0XHR9KTtcblx0fTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEhvdmVyIFZpc3VhbCBFZmZlY3RzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQXBwbGllcyBob3Zlci1pbiB2aXN1YWwgZWZmZWN0IHRvIGEgcG9pbnQgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5SG92ZXJFZmZlY3QgPSAoXG5cdGNpcmNsZTogU1ZHQ2lyY2xlRWxlbWVudCxcblx0Y29uZmlnOiBQb2ludFJlbmRlckNvbmZpZyA9IERFRkFVTFRfUE9JTlRfQ09ORklHXG4pOiB2b2lkID0+IHtcblx0Y2lyY2xlLnNldEF0dHJpYnV0ZShcInJcIiwgU3RyaW5nKGNvbmZpZy5ob3ZlclJhZGl1cykpO1xuXHRjaXJjbGUuc2V0QXR0cmlidXRlKFwib3BhY2l0eVwiLCBcIjFcIik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgaG92ZXIgdmlzdWFsIGVmZmVjdCBmcm9tIGEgcG9pbnQgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUhvdmVyRWZmZWN0ID0gKFxuXHRjaXJjbGU6IFNWR0NpcmNsZUVsZW1lbnQsXG5cdGNvbmZpZzogUG9pbnRSZW5kZXJDb25maWcgPSBERUZBVUxUX1BPSU5UX0NPTkZJR1xuKTogdm9pZCA9PiB7XG5cdGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyXCIsIFN0cmluZyhjb25maWcucmFkaXVzKSk7XG5cdGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJvcGFjaXR5XCIsIFN0cmluZyhjb25maWcub3BhY2l0eSkpO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVG9vbHRpcFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2x0aXBEYXRhIHtcblx0cmVhZG9ubHkgbGFiZWw6IHN0cmluZztcblx0cmVhZG9ubHkgeDogbnVtYmVyO1xuXHRyZWFkb25seSB5OiBudW1iZXI7XG5cdHJlYWRvbmx5IHhMYWJlbDogc3RyaW5nO1xuXHRyZWFkb25seSB5TGFiZWw6IHN0cmluZztcblx0cmVhZG9ubHkgY2F0ZWdvcnk6IHN0cmluZyB8IG51bGw7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRvb2x0aXAgZWxlbWVudCBmb3IgYSBwb2ludC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRvb2x0aXAgPSAoZGF0YTogVG9vbHRpcERhdGEpOiBIVE1MRGl2RWxlbWVudCA9PiB7XG5cdGNvbnN0IHRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHR0b29sdGlwLmNsYXNzTmFtZSA9IFwic2NhdHRlci10b29sdGlwXCI7XG5cblx0Y29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHR0aXRsZS5jbGFzc05hbWUgPSBcInNjYXR0ZXItdG9vbHRpcC10aXRsZVwiO1xuXHR0aXRsZS50ZXh0Q29udGVudCA9IGRhdGEubGFiZWw7XG5cdHRvb2x0aXAuYXBwZW5kQ2hpbGQodGl0bGUpO1xuXG5cdGNvbnN0IGZvcm1hdFZhbHVlID0gKHY6IG51bWJlcik6IHN0cmluZyA9PlxuXHRcdHYudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7IG1heGltdW1GcmFjdGlvbkRpZ2l0czogMiB9KTtcblxuXHRjb25zdCB2YWx1ZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHR2YWx1ZXMuY2xhc3NOYW1lID0gXCJzY2F0dGVyLXRvb2x0aXAtdmFsdWVzXCI7XG5cblx0Y29uc3QgeExpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHR4TGluZS50ZXh0Q29udGVudCA9IGAke2RhdGEueExhYmVsfTogJHtmb3JtYXRWYWx1ZShkYXRhLngpfWA7XG5cdHZhbHVlcy5hcHBlbmRDaGlsZCh4TGluZSk7XG5cblx0Y29uc3QgeUxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHR5TGluZS50ZXh0Q29udGVudCA9IGAke2RhdGEueUxhYmVsfTogJHtmb3JtYXRWYWx1ZShkYXRhLnkpfWA7XG5cdHZhbHVlcy5hcHBlbmRDaGlsZCh5TGluZSk7XG5cblx0aWYgKGRhdGEuY2F0ZWdvcnkpIHtcblx0XHRjb25zdCBjYXRlZ29yeUxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdGNhdGVnb3J5TGluZS50ZXh0Q29udGVudCA9IGBDYXRlZ29yeTogJHtkYXRhLmNhdGVnb3J5fWA7XG5cdFx0dmFsdWVzLmFwcGVuZENoaWxkKGNhdGVnb3J5TGluZSk7XG5cdH1cblxuXHR0b29sdGlwLmFwcGVuZENoaWxkKHZhbHVlcyk7XG5cblx0cmV0dXJuIHRvb2x0aXA7XG59O1xuXG4vKipcbiAqIFBvc2l0aW9ucyBhIHRvb2x0aXAgbmVhciBhbiBlbGVtZW50IHdpdGhvdXQgb3ZlcmZsb3dpbmcgdGhlIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGNvbnN0IHBvc2l0aW9uVG9vbHRpcCA9IChcblx0dG9vbHRpcDogSFRNTEVsZW1lbnQsXG5cdHRhcmdldFJlY3Q6IERPTVJlY3QsXG5cdGNvbnRhaW5lclJlY3Q6IERPTVJlY3Rcbik6IHZvaWQgPT4ge1xuXHRjb25zdCBvZmZzZXQgPSAxMjtcblx0bGV0IGxlZnQgPSB0YXJnZXRSZWN0LnJpZ2h0ICsgb2Zmc2V0IC0gY29udGFpbmVyUmVjdC5sZWZ0O1xuXHRsZXQgdG9wID0gdGFyZ2V0UmVjdC50b3AgLSBjb250YWluZXJSZWN0LnRvcDtcblxuXHQvLyBDaGVjayBpZiB0b29sdGlwIHdvdWxkIG92ZXJmbG93IHJpZ2h0XG5cdGNvbnN0IHRvb2x0aXBXaWR0aCA9IHRvb2x0aXAub2Zmc2V0V2lkdGggfHwgMjAwOyAvLyBFc3RpbWF0ZSBpZiBub3QgcmVuZGVyZWQgeWV0XG5cdGlmIChsZWZ0ICsgdG9vbHRpcFdpZHRoID4gY29udGFpbmVyUmVjdC53aWR0aCkge1xuXHRcdGxlZnQgPSB0YXJnZXRSZWN0LmxlZnQgLSB0b29sdGlwV2lkdGggLSBvZmZzZXQgLSBjb250YWluZXJSZWN0LmxlZnQ7XG5cdH1cblxuXHQvLyBDaGVjayBpZiB0b29sdGlwIHdvdWxkIG92ZXJmbG93IGJvdHRvbVxuXHRjb25zdCB0b29sdGlwSGVpZ2h0ID0gdG9vbHRpcC5vZmZzZXRIZWlnaHQgfHwgODA7XG5cdGlmICh0b3AgKyB0b29sdGlwSGVpZ2h0ID4gY29udGFpbmVyUmVjdC5oZWlnaHQpIHtcblx0XHR0b3AgPSBjb250YWluZXJSZWN0LmhlaWdodCAtIHRvb2x0aXBIZWlnaHQgLSBvZmZzZXQ7XG5cdH1cblxuXHQvLyBFbnN1cmUgbm90IG5lZ2F0aXZlXG5cdGxlZnQgPSBNYXRoLm1heCg4LCBsZWZ0KTtcblx0dG9wID0gTWF0aC5tYXgoOCwgdG9wKTtcblxuXHR0b29sdGlwLnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcblx0dG9vbHRpcC5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRXZlbnQgQXR0YWNobWVudFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50QXR0YWNobWVudENvbmZpZyB7XG5cdHJlYWRvbmx5IGFwcDogQXBwO1xuXHRyZWFkb25seSBob3ZlclBhcmVudDogSG92ZXJQYXJlbnQ7XG5cdHJlYWRvbmx5IGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudDtcblx0cmVhZG9ubHkgcG9pbnRJbmRleDogTWFwPHN0cmluZywgUmVuZGVyZWRQb2ludD47XG5cdHJlYWRvbmx5IHhMYWJlbDogc3RyaW5nO1xuXHRyZWFkb25seSB5TGFiZWw6IHN0cmluZztcblx0cmVhZG9ubHkgcG9pbnRDb25maWc6IFBvaW50UmVuZGVyQ29uZmlnO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIGFsbCBldmVudCBsaXN0ZW5lcnMgdG8gcG9pbnQgZWxlbWVudHMgaW4gdGhlIFNWRy5cbiAqIFJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uIHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgY29uc3QgYXR0YWNoUG9pbnRFdmVudHMgPSAoXG5cdHN2ZzogU1ZHU1ZHRWxlbWVudCxcblx0Y29uZmlnOiBFdmVudEF0dGFjaG1lbnRDb25maWdcbik6ICgoKSA9PiB2b2lkKSA9PiB7XG5cdGNvbnN0IHtcblx0XHRhcHAsXG5cdFx0aG92ZXJQYXJlbnQsXG5cdFx0Y29udGFpbmVyRWwsXG5cdFx0cG9pbnRJbmRleCxcblx0XHR4TGFiZWwsXG5cdFx0eUxhYmVsLFxuXHRcdHBvaW50Q29uZmlnLFxuXHR9ID0gY29uZmlnO1xuXG5cdGNvbnN0IGNsaWNrSGFuZGxlciA9IGNyZWF0ZUNsaWNrSGFuZGxlcih7IGFwcCB9KTtcblx0Y29uc3QgaG92ZXJIYW5kbGVyID0gY3JlYXRlSG92ZXJIYW5kbGVyKHtcblx0XHRhcHAsXG5cdFx0aG92ZXJQYXJlbnQsXG5cdFx0c291cmNlOiBcInNjYXR0ZXItcGxvdFwiLFxuXHR9KTtcblxuXHRsZXQgYWN0aXZlVG9vbHRpcDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuXHRjb25zdCBoYW5kbGVNb3VzZUVudGVyID0gKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XG5cdFx0Y29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIFNWR0NpcmNsZUVsZW1lbnQ7XG5cdFx0aWYgKCF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2NhdHRlci1wb2ludFwiKSkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBmaW5kUG9pbnRGcm9tRWxlbWVudCh0YXJnZXQsIHBvaW50SW5kZXgpO1xuXHRcdGlmIChwb2ludCA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdFx0Ly8gVmlzdWFsIGVmZmVjdFxuXHRcdGFwcGx5SG92ZXJFZmZlY3QodGFyZ2V0LCBwb2ludENvbmZpZyk7XG5cblx0XHQvLyBUcmlnZ2VyIGhvdmVyIHByZXZpZXdcblx0XHRob3ZlckhhbmRsZXIocG9pbnQsIHRhcmdldCwgZXZlbnQpO1xuXG5cdFx0Ly8gU2hvdyB0b29sdGlwXG5cdFx0aWYgKGFjdGl2ZVRvb2x0aXApIHtcblx0XHRcdGFjdGl2ZVRvb2x0aXAucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0YWN0aXZlVG9vbHRpcCA9IGNyZWF0ZVRvb2x0aXAoe1xuXHRcdFx0bGFiZWw6IHBvaW50LmxhYmVsLFxuXHRcdFx0eDogcG9pbnQueCxcblx0XHRcdHk6IHBvaW50LnksXG5cdFx0XHR4TGFiZWwsXG5cdFx0XHR5TGFiZWwsXG5cdFx0XHRjYXRlZ29yeTogcG9pbnQuY2F0ZWdvcnksXG5cdFx0fSk7XG5cdFx0Y29udGFpbmVyRWwuYXBwZW5kQ2hpbGQoYWN0aXZlVG9vbHRpcCk7XG5cblx0XHRjb25zdCB0YXJnZXRSZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IGNvbnRhaW5lclJlY3QgPSBjb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRwb3NpdGlvblRvb2x0aXAoYWN0aXZlVG9vbHRpcCwgdGFyZ2V0UmVjdCwgY29udGFpbmVyUmVjdCk7XG5cdH07XG5cblx0Y29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9IChldmVudDogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuXHRcdGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBTVkdDaXJjbGVFbGVtZW50O1xuXHRcdGlmICghdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcInNjYXR0ZXItcG9pbnRcIikpIHJldHVybjtcblxuXHRcdC8vIFJlbW92ZSB2aXN1YWwgZWZmZWN0XG5cdFx0cmVtb3ZlSG92ZXJFZmZlY3QodGFyZ2V0LCBwb2ludENvbmZpZyk7XG5cblx0XHQvLyBSZW1vdmUgdG9vbHRpcFxuXHRcdGlmIChhY3RpdmVUb29sdGlwKSB7XG5cdFx0XHRhY3RpdmVUb29sdGlwLnJlbW92ZSgpO1xuXHRcdFx0YWN0aXZlVG9vbHRpcCA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IGhhbmRsZUNsaWNrID0gKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XG5cdFx0Y29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIFNWR0NpcmNsZUVsZW1lbnQ7XG5cdFx0aWYgKCF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2NhdHRlci1wb2ludFwiKSkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBmaW5kUG9pbnRGcm9tRWxlbWVudCh0YXJnZXQsIHBvaW50SW5kZXgpO1xuXHRcdGlmIChwb2ludCA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdFx0Y2xpY2tIYW5kbGVyKHBvaW50LCBldmVudCk7XG5cdH07XG5cblx0Ly8gQXR0YWNoIGxpc3RlbmVycyB0byB0aGUgU1ZHIChldmVudCBkZWxlZ2F0aW9uKVxuXHRzdmcuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgaGFuZGxlTW91c2VFbnRlciwgdHJ1ZSk7XG5cdHN2Zy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBoYW5kbGVNb3VzZUxlYXZlLCB0cnVlKTtcblx0c3ZnLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG5cblx0Ly8gUmV0dXJuIGNsZWFudXAgZnVuY3Rpb25cblx0cmV0dXJuICgpOiB2b2lkID0+IHtcblx0XHRzdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgaGFuZGxlTW91c2VFbnRlciwgdHJ1ZSk7XG5cdFx0c3ZnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIGhhbmRsZU1vdXNlTGVhdmUsIHRydWUpO1xuXHRcdHN2Zy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuXG5cdFx0aWYgKGFjdGl2ZVRvb2x0aXApIHtcblx0XHRcdGFjdGl2ZVRvb2x0aXAucmVtb3ZlKCk7XG5cdFx0XHRhY3RpdmVUb29sdGlwID0gbnVsbDtcblx0XHR9XG5cdH07XG59O1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BLElBQUFBLG1CQUF1Qjs7O0FDRHZCLElBQUFDLG1CQUtPOzs7QUN5R0EsSUFBTSxrQkFBZ0M7QUFBQSxFQUMzQyxVQUFVO0FBQUEsRUFDVixRQUFRO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0Y7QUErQk8sSUFBTSxtQkFBdUM7QUFBQSxFQUNsRCxPQUFPO0FBQUEsRUFDUCxRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsSUFDTixLQUFLO0FBQUEsSUFDTCxPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsRUFDUjtBQUNGOzs7QUM3SUEsSUFBTSxlQUFlLENBQUMsVUFBNEI7QUFDaEQsTUFBSSxVQUFVLFFBQVEsVUFBVTtBQUFXLFdBQU87QUFDbEQsTUFBSSxPQUFPLFVBQVUsWUFBWSxVQUFVLFFBQVEsYUFBYSxPQUFPO0FBQ3JFLFVBQU0sSUFBSTtBQUNWLFdBQU8sRUFBRSxRQUFRO0FBQUEsRUFDbkI7QUFDQSxTQUFPLENBQUM7QUFDVjtBQVVPLElBQU0sc0JBQXNCLENBQ2pDLE9BQ0EsZUFDNEI7QUFDNUIsTUFBSTtBQUVGLFVBQU0sUUFBUSxNQUFNLFNBQVMsVUFBOEI7QUFHM0QsUUFBSSxVQUFVLFFBQVEsVUFBVSxVQUFhLGFBQWEsS0FBSyxHQUFHO0FBQ2hFLGFBQU8sRUFBRSxTQUFTLE9BQU8s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
